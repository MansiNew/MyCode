
OOPS=>*abstract class cannot provide implementation of interface abstract method 

Inheritance=>
*multiple not supported by java because ambiguity problem will occur in code
*IS A relationship
*Can we pass an object of a subclass to a method expecting an object of the super class? (answer)
Answer: Yes,
*How to call a method of a subclass, if you are holding an object of the subclass in a reference variable of type superclass? 

-----------------------------------------------------------------------------
Q Why do we need to use inheritance?
We can reuse the code from the base class.
Using inheritance, we can increase features of class or method by overriding.
Inheritance is used to use the existing features of class.
It is used to achieve runtime polymorphism i.e method overriding.
-------------------------------------------------------------------------
Q What happens if both superclass and subclass have a field with the same name?

Ans: Only subclass members are accessible if an object of subclass is instantiated.
----------------------------------------------------------------------------
Q  Is interface inherited from the Object class?

Ans: No.
----------------------------------------------------------------------------------
Q Are constructor and instance initialization block inherited to subclass?

Ans: No, constructor and instance initialization block of the superclass cannot be inherited to its 
subclass but they are executed while creating an object of the subclass.
------------------------------------------------------------------------------------
public class A { 
   int x = 20;
}
public class B extends A {
   int x = 30;
}
public class Test {
public static void main(String[] args) 
{
   B b = new B();
   System.out.println(b.x); 
 
   A a = new A();
   System.out.println(a.x);
 
   A a2 = new B();
   System.out.println(a2.x);
  }
}

o/p=>   30,20,20  //because if we create object subclass and reff of parent then parent value will be called
---------------------------------------------------------------------------------
* if we create method in parent class and its not compalsury to override in child class.
-------------------------------------------------------------------------------
public class A 
{
   private int x = 50;	
   protected int y = 100;
    int z = 200;
}
package pack2;
import pack1.A;
public class B extends A {

}
import pack2.B;
public class Test {
public static void main(String[] args) 
{
   B b = new B();
   System.out.println(b.x);

   System.out.println(b.y);
   System.out.println(b.z);
  }
}
Ans: No, the code will not compile successfully because of two compile-time errors.

First error is in line System.out.println(b.x); because private members cannot be accessed in the subclass.
Second error is in line System.out.println(b.y); because default members of superclass can be accessed in the subclass within the same package only.
------------------------------------------------------------------------------------------
public static void main(String[] args) {
Product is a child and A parent	
A a=new Product();
Product p=new Product();
A a1=new A();
a1.print();
a1=p;//here child method will call because child object store in parent reff
//a.tester();
a1.print();

p=a1//not possible class cast exception
}
-----------------------------------------------------------*********---------------------------------
encapsulation=>

Q
What are the important features of Encapsulation?

Ans: Encapsulation means combining the data of our application and its manipulation in one place.
*It keeps the data and codes safe from external inheritance. Thus, Encapsulation helps to achieve security.
*The fields of a class can be made read-only or write-only.
--------------------------------------------------------------------------------------------------------------------
Q What is a Tightly encapsulated class in Java?

Ans: If each variable is declared as private in the class, it is called tightly encapsulated class in Java. 
For tightly encapsulated class, we are not required to check whether class contains getter and setter method or not 
------------------------------------------------------------------------------------------
QWhat are getter and setter methods in Java?

Ans: In Java, setter method is a method that is used for updating the values of a variable. This method is
 also known as mutator method.

Getter method is a method that is used to retrieve the value of a variable or return 
the value of the private member variable. This method is also known as an accessor method
------------------------------------------------------------------------------------------
*private double x=9;  //it will not give any error
-----------------------------------------------------------------------------------------
Q  Explain design pattern based on encapsulation in java?

Ans: In many design patterns, Java uses the encapsulation technique and one of 
them is Factory pattern which is used to create the objects.
--------------------------------------------------*******--------------------------------------------
Polymorpphism=>

method overloading=>
 public void print() {
		System.out.println("hello A ");
	}
	
	public int print() {
		return 34;
	}
//it is not possible

public void print(int x) {
		System.out.println("hello A ");
	}
	
	public int print() {
		return 34;
	}
//this is possible

public void print(int x) {
		System.out.println("hello A ");
	}
	
	public static int print() {
		return 34;
	}

//it is possible

*Method overloading increases the readability of the program.

*static int add(int a,int b){return a+b;}  
static double add(int a,int b){return a+b;}  //in this scenario ambiguity will occur
----------------------------------------------------------------------------------------
Q Can we overload java main() method?
Yes, by method overloading. You can have any number of main methods in a class by method overloading.
 But JVM calls main() method which receives string array as arguments only. Let's see the simple example:

class TestOverloading4{  
public static void main(String[] args){System.out.println("main with String[]");}  
public static void main(String args){System.out.println("main with String");}  
public static void main(){System.out.println("main without args");}  
}  


Output:

main with String[]
------------------------------------------------------************---------------------------------------------
Method overriding=>

*we cannot change return type of method
*static method overriding is not possible if we create 2 same name methods in parent and child Then call will depend
on reff type
_---------------------------------------------------------------------------------------------
CASE1:-

interface T {
public void print();

default void printer() {
	System.out.println("default method1 T");
}
}


interface U {
public void print();

default void printer() {
	System.out.println("default method1 T");
}
}



CAEE 3:-If two interface have same abstract method and in child class provide implementation of those methods and call
 by child object we cannot pridict which interface method will call

public class ChildTest implements D,T {
	
public static void main(String[] args) {
	ChildTest c=new ChildTest();
	
	c.print();
	
}
@Override
public void print() {
	// TODO Auto-generated method stub
	
}

}


CASE4:-

default method without overriding

public interface D {
	default void terst() {
		System.out.println("d");
	}
}

public class ChildTest implements D {
	
public static void main(String[] args) {
	ChildTest c=new ChildTest();
	c.terst();
}
}
o/p=>  d

CASE5:-

with  default overriding

public class ChildTest implements D {
	public  void terst() {
		System.out.println("child");
	}
public static void main(String[] args) {
	ChildTest c=new ChildTest();
	c.terst();
}
}

o/p=>child

CASE6:-
If two interface have same default method then default method overriding is compulsary 
and also provide which interface method you want override

public interface D {
	
	public default void first() {
		System.out.println("D first");
	}
}

public interface D {
	
	public default void first() {
		System.out.println("D first");
	}
}


public class ChildTest implements D,T {
	
public static void main(String[] args) {
	ChildTest c=new ChildTest();
	c.first();
	
}

@Override
public void first() {
	// TODO Auto-generated method stub
	D.super.first();
}

}

----------------------------------------------
Covariant return type=>

CASE1=>public class Tests {
	
	public  Tests tester() {
		return new Tests();
	}

}


public class ChildTest extends Tests {
	public  Tests tester() {
		return new Tests();
	}

	public static void main(String[] args) {
		ChildTest t=new ChildTest();
		System.out.println(t.tester());
	}

}

CASE2=>

public class ChildTest extends Tests {
	public  	ChildTest tester() {
		return new ChildTest();
	}

	public static void main(String[] args) {
		ChildTest t=new ChildTest();
		System.out.println(t.tester());
	}

}
-----------------------------------------------------------------*********--------------------------------------------------
Abstraction=>hiding of implementstion detatils.we can achieve through interface and abstract class

abstract class=>*0 to 100% abstraction,contain both abstract and concreate methods
                *we can create constructor in abstract class but not create object
                *

CASE:=
     Abstract class with constructor

abstract public class Tests {
	int x;
	String name;
	public Tests(int x, String name) {
		super();
		this.x = x;
		this.name = name;
		System.out.println(x);
		System.out.println(name);
	}
	
	public void tester1() {
		System.out.println("tester1");
	}
	
}


public class ChildTest extends Tests {
	

	public ChildTest(int x, String name) {
		super(x, name);
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		ChildTest c=new ChildTest(34,"tomi");
		
	}

}

--------------------------------------------------------------------
*Is abstract class allow to define private, final, static, and concrete methods?

Ans: Yes.
----------------------------------------------------------------------
Q Can we define an abstract method inside non-abstract class (concrete class)?

Ans: No, we cannot define an abstract method in non-abstract class.*variable acnnot be abstract

--------------------------------------------------------------------
public abstract class A {
  abstract void m1(A a);
}
public class B extends A {
void m1(A a) {
  System.out.println("One"); 	
 }
}
public class C extends B {
void m1(B b) {	
 System.out.println("Two");
 super.m1(new B());
 }
}
public class Test {
public static void main(String[] args) {
C c = new C();
 c.m1(new B());
  }
}
Ans: Yes, the above code will be compiled successfully. The output of above program is Two, One.

-------------------------
*Programmer can implement abstract method to perform different tasks depending on the need.
We can easily manage code.
*public ->protected is not possible 
*class cannot be private, protected ,static but it can be without any modifier or final
---------------------------------------------------------------------
Q   Can an abstract class be final?
A: Yes, an abstract class can be final, meaning it cannot be extended by any subclass.
 However, this is usually not a recommended practice, 
as it limits the ability to reuse and extend the functionality of the class.

---------------------------------------------------------************-------------------------------------------------------

Interface=>*it can be abstract and every variable by default static and 
final and we cannot create object and contain only abstract methods
----------------------------------------------------
Q5. Can an interface have variables?
A: Yes, an interface can have variables, but they must be public, static, and final. These variables are called 
constants because their values cannot be changed once they are initialized.
---------------------------------------
marker interface =>empty interface ex serializable ,clonable,remote,annotation
*Its purpose is to provide a tag or marker to a class, indicating that the class has some special behavior or characteristic.
--------------------------------------------
Q When would you use an interface over an abstract class?
A: You would use an interface over an abstract class when you want to define a contract that classes must follow
 without specifying how they should implement it. This allows for greater flexibility and code reuse, as any class
 that implements the interface can be used in place of another.
 An abstract class, on the other hand, is more appropriate when you want to provide a base implementation for 
its subclasses,
-----------------------------------------------------------
Q   What are the benefits of using marker interfaces in Java?
Marker interfaces provide a way to convey additional information about a class or object that cannot be 
expressed through methods or variables. They also provide a way to group classes together based on a common 
characteristic or behavior.This can help make code more readable and maintainable.
-----------------------------------------------------------
Q What is the purpose of a functional interface?
The purpose of a functional interface is to facilitate the implementation 
of lambda expressions and functional programming in Java. It allows developers to define 
a functional signature and then create an implementation for that signature, which can be used as a functional object.
--------------------------------------------------------------- 
Can we use annotations instead of marker interfaces in Java  yes
-------------------------------------------------------
Q  Can an interface have private methods?
A: Yes, an interface can have private methods since Java 9. Private methods in an interface 
can be used to reduce code duplication by allowing multiple default or static methods to share common
 code without exposing that code to the classes that implement the interface.
__________________________________________________________________________________________________________________
STATIC VARIABLE=>

*No, static keyword cannot be applied with outer or top-level class but an inner class can be static.
*its use to show common properties like collegename
public class Myclass 
{
   private int x = 10;
   static int m1() {
       int y = x;
       return y;
    }
public static void main(String[] args) {
     m1();
   }
}

*not compiled successfully because instance variable is not accessed from static area
================================================
public class Myclass 
{
   private int x = 10;
   static int m1()
  {
      Myclass obj = new Myclass();
       int y = obj.x;
       return y;
   }
public static void main(String[] args) {
     System.out.println(m1());
   }
}

*compiled successfully
=============================================================
The main use of java static keyword is as follows:

The static keyword can be used when we want to access the data, method, or block of the class without any object creation.
It can be used to make the programs more memory efficient.
===============================================================================
When a class is loaded into the memory at runtime, the static variable is created and initialized into the common memory location only once.
========================================================================================
public class Myclass 
{
   static int a = 20;
   static int b = 30;
   static int c = 40;
   Myclass() 
  {
      a = 200;
   }
static void m1() {
      b = 300;
}
static {
      c = 400;
}
public static void main(String[] args) {
     System.out.println(a);
     System.out.println(b);
     System.out.println(c);
   }
}
Ans: Output: 20, 30, 400.
*because at the time of class loading static block will load and assign new value to c
==============================================================================================
public class Myclass {
     static int a = 20;
Myclass() {
     a = 200;
}
public static void main(String[] args) {
    new Myclass();
    System.out.println(a);
  }
}

*static variable reinitialization is possible
===================================================================================
*All static variables are stored in PermGen space of the heap memory.
=========================================================================
) A static variable is also called class variable whereas, an instance variable is also called non-static variable.

b) Class variable can be accessed inside a static block, instance block, static method, instance method, and method of the inner class whereas, instance variable can be accessed only inside the instance members, and method of the inner class.

c) Class variable is always resolved during compile time whereas, instance variable is resolved during the runtime.

4) Static variable cannot be serialized in Java whereas, instance variable can be serialized.
==========================================================================
public class Myclass {
  static int a = 20;
 Myclass() {
       a++;
  }
 void m1()  {
       a++;
       System.out.println(a);
  }
public static void main(String[] args) 
{
    Myclass obj = new Myclass();
    Myclass obj2 = new Myclass();
    Myclass obj3 = new Myclass();
       obj3.m1();
   }
}
Ans: Output: 24.
===================================================================================
public class Test
{
   Test() {
       m2();
   }
  void m1() {
        System.out.println("Instance method");
   }
  static void m2() {
        System.out.println("Static method");
        m1();
   }
public static void main(String[] args)
{
      new Test();
  }
}
Ans: error at time of calling m1()
=========================================********==============================================
STATIC METHODS=>
Q) Why is the Java main method static?
Ans) It is because the object is not required to call a static method. If it were a non-static method, 
JVM creates an object first then call main() method that will lead the problem of extra memory allocation.

* Yes, from Java 8 and onwards, the interface allows to define a static method with body.
* No, In the entire core java, this and super keywords are not allowed inside the static region.
* we can overload static methods directly but Yes, we can overload static methods but override them. This is because they are bound with class, not instance.
*No, we cannot override static methods because static methods belong to a class, not individual objects, and are resolved at compile time by java compiler.


why we use static methods=>
*You can access static methods from outside of the class in which they are defined. This is not possible with non-static methods.
and we dont want create object then we can go for static method
* we can create utility classes
*A utility class is a class that is just a namespace for functions. No instances of it can exist, and all its members are static. For example, java. lang. Math and java.
========================================*********==============================================
STATIC INITIALIZER BLOCK=>

*When the dot class file is loaded into memory, static block is executed. After executing the static block, JVM calls the main method to start execution. Therefore, static block is executed before the main method.

*Is used to initialize the static data member.

---------------------------------------
Q) Can we execute a program without main() method?
Ans) No, one of the ways was the static block, but it was possible till JDK 1.6. Since JDK 1.7, it is not possible to execute a Java class without the main method.

class A3{  
  static{  
  System.out.println("static block is invoked");  
  System.exit(0);  
  }  
}  

---------------------------------------------
we want to write that logic inside static block that is executed during the class loading.
we want to change the default value of static variables.
----------------------------------------------------

*public class Myclass {
  static int a = 20;
  static {
        a++;
   }
{
    a++;
    System.out.println(a);
}
public static void main(String[] args) 
{
   Myclass obj = new Myclass();
   Myclass obj2 = new Myclass();
   Myclass obj3 = new Myclass();
  }
}
Ans: Output: 22, 23, 24.

*Local variable intialization is cumpalsory but at atime craetion if we craete without initialize then 
we not get any error but at time use it will throw compile time error.
__________________________________________________________________________________________________________________-
INSTANCE/NON STATIC=>
The variables that are declared inside the class but outside the scope of any method are called instance variables in Java.
The instance variable is initialized at the time of the class loading or when an object of the class is created.

To use an instance variable an object of the class must be created.
An instance variable is destroyed when the object it is associated with is destroyed.
An instance variable does not compulsory need to be initialized.
Instance variables are accessible inside the same class that declares them.
It cannot be declared static, abstract, striftp, synchronized, and native.
It can be declared final and transient.
*Used to store values that are needed to be accessed by different methods of the class.
*Well variables are stored in RAM memory. 
public class ComparatorTest  {
int a=50;
	
	
{
    a++;
    System.out.println(a);
}
public static void main(String[] args) {
	
	ComparatorTest c1=new ComparatorTest();
	ComparatorTest c2=new ComparatorTest();
	ComparatorTest c3=new ComparatorTest();
	
	
	
}
}
o/p=>51,51,51
=============================================********==============================================================================
instance method=>
An instance method is a method that belongs to instances of a class, not to the class itself.


=============================================********=============================================================================
instance block=>
*Instance Initializer block is used to initialize the instance data member. It run each time when object of the class is created.
*Why use instance initializer block?
Suppose I have to perform some operations while assigning value to instance data member

class Bike7{  
    int speed;  
      
    Bike7(){System.out.println("speed is "+speed);}  
   
    {speed=100;}  
       
    public static void main(String args[]){  
    Bike7 b1=new Bike7();  
    Bike7 b2=new Bike7();  
    }      
} 

 
*It will execute before constructor
*class Bike8{  
    int speed;  
      
    Bike8(){System.out.println("constructor is invoked");}  
   
    {System.out.println("instance initializer block invoked");}  
       
    public static void main(String args[]){  
    Bike8 b1=new Bike8();  
    Bike8 b2=new Bike8();  
    }      
}  
Test it Now
Output:instance initializer block invoked
       constructor is invoked
       instance initializer block invoked
       constructor is invoked

*does not depend on the constructor execution.
*instance initializer block is invoked after the parent class constructor is invoked (i.e. after super() constructor call).
*The instance initializer block comes in the order in which they appear.


class A{  
A(){  
System.out.println("parent class constructor invoked");  
}  
}  
class B2 extends A{  
B2(){  
super();  
System.out.println("child class constructor invoked");  
}  
  
{System.out.println("instance initializer block is invoked");}  
  
public static void main(String args[]){  
B2 b=new B2();  
}  
}  
Test it Now
Output:parent class constructor invoked
       instance initializer block is invoked
       child class constructor invoked


class A{  
A(){  
System.out.println("parent class constructor invoked");  
}  
}  
  
class B3 extends A{  
B3(){  
super();  
System.out.println("child class constructor invoked");  
}  
  
B3(int a){  
super();  
System.out.println("child class constructor invoked "+a);  
}  
  
{System.out.println("instance initializer block is invoked");}  
  
public static void main(String args[]){  
B3 b1=new B3();  
B3 b2=new B3(10);  
}  
}  


when we use iib=>
Now you observe that on every object creation, the constructor logic is executed corresponding to the object, and also corresponding IIB is executed.

Here, the constructor logic is specific to the particular objects but instance block logic is common for all objects.
_______________________________________________________________________________________________________________________
LOCAL BLOCK=>A block defined inside a method, block, or constructor is called local block in Java. It is also called inner block in Java.

It will be executed whenever the enclosing method, constructor, or block is executed. 
public void methodwithInnerblock()
{  // Outer block starts here with opening braces.
  int x = 20;
  System.out.println(" Outer block");
 
 { // Inner or local block starts here with next opening braces.
   int y = 30;
   System.out.println("Inner block");
 } // Inner block ends here.
} // Outer block ends here.
_____________________________________________________________________________________________________________________________
Super/THIS=>
Super=>The super keyword in Java is a reference variable which is used to refer immediate parent class object.
Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred by super reference variable.

Usage of Java super Keyword->

*super can be used to refer immediate parent class instance variable.
class Animal{  
String color="white";  
}  
class Dog extends Animal{  
String color="black";  
void printColor(){  
System.out.println(color);//prints color of Dog class  
System.out.println(super.color);//prints color of Animal class  
}  
}  
class TestSuper1{  
public static void main(String args[]){  
Dog d=new Dog();  
d.printColor();  
}}  
-----------------------------------------------------------------
*super can be used to invoke immediate parent class method.
class Animal{  
void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
void eat(){System.out.println("eating bread...");}  
void bark(){System.out.println("barking...");}  
void work(){  
super.eat();  
bark();  
}  
}  
class TestSuper2{  
public static void main(String args[]){  
Dog d=new Dog();  
d.work();  
}}  
-------------------------------------------------------------------
*super() can be used to invoke immediate parent class constructor.
class Animal{  
Animal(){System.out.println("animal is created");}  
}  
class Dog extends Animal{  
Dog(){  
super();  
System.out.println("dog is created");  
}  
}  
class TestSuper3{  
public static void main(String args[]){  
Dog d=new Dog();  
}}  
Test it Now
Output:

animal is created
dog is created
--------------------------------------------------------------------
Important rules=>
*If we create default constructor in parent class then not neccessary to create default constructor in child.
*But if we create perametrized constructor in parent without  explicitely default constructor then it is necccessary to create perametrized 
constructor in child class also otherwise we will get compile time error.
*But if we create both default and perametrized in parent then not neccessary to create perametrized in child class.
*If we pass only two perameter in parent constructor ,so in child constructor we can also pass extra perameter.
*Super cannot use in static block
*Sper() is always first statement and super can be second


-------------------------------------------------------------------------
logical programs->
when we use super(a,b) in real->

Here, Emp class inherits People class so all the properties of Person will be inherited to Emp by default. To initialize all the property,
 we are using parent class constructor from child class. In such way, we are reusing the parent class constructor.

public class People {
	public void test() {
		System.out.println("test method");
	}
	String add="team";
int id;
String name;
String city;
public People() {
	
}

public People(int id, String name, String city) {
	super();
	this.id = id;
	this.name = name;
	this.city = city;
	System.out.println(id);
	System.out.println(name);
}

}

*Can we use both "this" and "super" in a constructor ?
No, because both this and super should be the first statement.
 public Employee(int id,String city,String name) {
		 super(id,city,name);
		super.test();
		 System.out.println(super.add);
		 System.out.println(this.salary);
	 }
*but this is possible


When Need of super keyword ?
Whenever the derived class is inherits the base class features, there is a possibility that base class features are similar to derived class features and JVM gets an ambiguity. 
In order to differentiate between base class features and derived class features must be preceded by super keyword.
===========================================================================**********=================================================================================================
this->* this is a reference variable that refers to the current object.
1) this: to refer current class instance variable
The this keyword can be used to refer current class instance variable. If there is ambiguity between the instance variables and parameters, this keyword resolves the problem of ambiguity.

Let's understand the problem if we don't use this keyword by the example given below:

class Student{  
int rollno;  
String name;  
float fee;  
Student(int rollno,String name,float fee){  
rollno=rollno;  
name=name;  
fee=fee;  
}  
void display(){System.out.println(rollno+" "+name+" "+fee);}  
}  
class TestThis1{  
public static void main(String args[]){  
Student s1=new Student(111,"ankit",5000f);  
Student s2=new Student(112,"sumit",6000f);  
s1.display();  
s2.display();  
}}  
Test it Now
Output:

0 null 0.0
0 null 0.0
In the above example, parameters (formal arguments) and instance variables are same. So, we are using this keyword to distinguish local variable and instance variable.

Solution of the above problem by this keyword
class Student{  
int rollno;  
String name;  
float fee;  
Student(int rollno,String name,float fee){  
this.rollno=rollno;  
this.name=name;  
this.fee=fee;  
}  
void display(){System.out.println(rollno+" "+name+" "+fee);}  
}  
  
class TestThis2{  
public static void main(String args[]){  
Student s1=new Student(111,"ankit",5000f);  
Student s2=new Student(112,"sumit",6000f);  
s1.display();  
s2.display();  
}}  
-----------------------------------------------------------------------------------------
2) this: to invoke current class method
You may invoke the method of the current class by using the this keyword. 

class A{  
void m(){System.out.println("hello m");}  
void n(){  
System.out.println("hello n");  
//m();//same as this.m()  
this.m();  
}  
}  
class TestThis4{  
public static void main(String args[]){  
A a=new A();  
a.n();  
}}  

------------------------------------------------------------------------------------------
3) this() : to invoke current class constructor
The this() constructor call can be used to invoke the current class constructor. It is used to reuse the constructor. In other words, it is used for constructor chaining.

Calling default constructor from parameterized constructor:

class A{  
A(){System.out.println("hello a");}  
A(int x){  
this();  
System.out.println(x);  
}  
}  
class TestThis5{  
public static void main(String args[]){  
A a=new A(10);  
}}  
-------------------------------------------------------------------------------------------

Calling parameterized constructor from default constructor:

class A{  
A(){  
this(5);  
System.out.println("hello a");  
}  
A(int x){  
System.out.println(x);  
}  
}  
class TestThis6{  
public static void main(String args[]){  
A a=new A();  
}}  
----------------------------------------------------------------------------------------------
Real usage of this() constructor call
The this() constructor call should be used to reuse the constructor from the constructor. It maintains the chain between the constructors i.e. it is used for constructor chaining. Let's see the example given below that displays the actual use of this keyword.

class Student{  
int rollno;  
String name,course;  
float fee;  
Student(int rollno,String name,String course){  
this.rollno=rollno;  
this.name=name;  
this.course=course;  
}  
Student(int rollno,String name,String course,float fee){  
this(rollno,name,course);//reusing constructor  
this.fee=fee;  
}  
void display(){System.out.println(rollno+" "+name+" "+course+" "+fee);}  
}  
class TestThis7{  
public static void main(String args[]){  
Student s1=new Student(111,"ankit","java");  
Student s2=new Student(112,"sumit","java",6000f);  
s1.display();  
s2.display();  
}}  
----------------------------------------------------------------
4) this: to pass as an argument in the method
The this keyword can also be passed as an argument in the method. It is mainly used in the event handling. Let's see the example:

class S2{  
  void m(S2 obj){  
  System.out.println("method is invoked");  
  }  
  void p(){  
  m(this);  
  }  
  public static void main(String args[]){  
  S2 s1 = new S2();  
  s1.p();  
  }  
}  
-------------------------------------------------------------------
class B{  
  A4 obj;  
  B(A4 obj){  
    this.obj=obj;  
  }  
  void display(){  
    System.out.println(obj.data);//using data member of A4 class  
  }  
}  
  
class A4{  
  int data=10;  
  A4(){  
   B b=new B(this);  
   b.display();  
  }  
  public static void main(String args[]){  
   A4 a=new A4();  
  }  
} 


o/p=>10
------------------------------------------------------------
 this keyword can be used to return current class instance->
class A{  
A getA(){  
return this;  
}  
void msg(){System.out.println("Hello java");}  
}  
class Test1{  
public static void main(String args[]){  
new A().getA().msg();  
}  
}  
Test it Now
Output:

Hello java
-----------------------------------------------------------------
Proving this keyword
Let's prove that this keyword refers to the current class instance variable.
 In this program, we are printing the reference variable and this, output of both variables are same.

class A5{  
void m(){  
System.out.println(this);//prints same reference ID  
}  
public static void main(String args[]){  
A5 obj=new A5();  
System.out.println(obj);//prints the reference ID  
obj.m();  
}  
}  
---------------------------------------------------------------------------
rules=>*this cannot be used inside static contaxt
*this .x and this.m()  it can be second statement
*this() is aleways first statement
__________________________________________________________________________________________________________________________________
CONSTRUCTOR=>
*In Java, a constructor is a block of codes similar to the method. It is called when an instance of the class is created. 
At the time of calling constructor, memory for the object is allocated in the memory.
*It is a special type of method which is used to initialize the object.
*Every time an object is created using the new() keyword, at least one constructor is called.
*It calls a default constructor if there is no constructor available in the class. In such case, Java compiler provides a default constructor by default.
*There are two types of constructors in Java: no-arg constructor, and parameterized constructor.
Note: It is called constructor because it constructs the values at the time of object creation. It is not necessary to
 write a constructor for a class.
*Constructor name must be the same as its class name
*A Constructor must have no explicit return type
*A Java constructor cannot be abstract, static, final, and synchronized
*If we create perametrized constructor then its neccessary to create default construct at the time of object  creation without args
*Constructor overloading in Java is a technique of having more than one constructor with different parameter lists. 
They are arranged in a way that each constructor performs a different task.
------------------------------------------------------------------------------------
Q) What is the purpose of a default constructor?
The default constructor is used to provide the default values to the object like 0, null, etc., depending on the type.

class Student3{  
int id;  
String name;  
//method to display the value of id and name  
void display(){System.out.println(id+" "+name);}  
  
public static void main(String args[]){  
//creating objects  
Student3 s1=new Student3();  
Student3 s2=new Student3();  
//displaying values of the object  
s1.display();  
s2.display();  
}  
}  


Why use the parameterized constructor?
The parameterized constructor is used to provide different values to distinct objects. However, you can provide the same values also.

Q) Does constructor return any value?
Yes, it is the current class instance (You cannot use return type yet it returns a value).

Can constructor perform other tasks instead of initialization?
Yes, like object creation, starting a thread, calling a method, etc. You can perform any operation in the constructor as you perform in the method.

Q  What happens if we provide a return type to a constructor?
If we provide a return type to a constructor, it will function as a general method. But, the compiler will display a warning message, "This method has a Constructor name".

Consider the below example:

public class TestConstructor {  
    int TestConstructor()  
    {  
        return 0;  
    }  


*scenarios when we need a private constructor:
Internal Constructor chaining
Singleton class design pattern


Q) what will happen when a constructor is declared as protected?
Generally, when we declare a method as protected, other classes can access that method in a different package by using inheritance only. 
But, when we declare a constructor protected, it behaves slightly differently than a method. 
The protected constructor can only be accessed by using a super keyword according to Java language standards.

Q)Why constructor name is similar to the class name?
When we create an object of a class using a new keyword, it should have information about that particular class. 
That is why the constructor's name must be similar to the class name.

QWhy return type is not allowed for the constructor?
The return type is not allowed in the constructor because if we provide a return type in the constructor, it will act as the normal method.
-------------------------------------------------------------------------------------------------
Difference between constructor and method in Java


Java Constructor	                                                             Java Method
A constructor is used to initialize the state of an object.	                   A method is used to expose the behavior of an object.
A constructor must not have a return type.	                                   A method must have a return type.
The constructor is invoked implicitly.	                                            The method is invoked explicitly.
The Java compiler provides a default constructor 
if you don't have any constructor in a class.	                                 The method is not provided by the compiler in any case.
The constructor name must be same as the class name.	
--------------------------------------------------------------------------------------------------
*copy constructor is not supported by java 
There are many ways to copy the values of one object into another in Java. They are:

By constructor
class Student6{  
    int id;  
    String name;  
    //constructor to initialize integer and string  
    Student6(int i,String n){  
    id = i;  
    name = n;  
    }  
    //constructor to initialize another object  
    Student6(Student6 s){  
    id = s.id;  
    name =s.name;  
    }  
    void display(){System.out.println(id+" "+name);}  
   
    public static void main(String args[]){  
    Student6 s1 = new Student6(111,"Karan");  
    Student6 s2 = new Student6(s1);  
    s1.display();  
    s2.display();  
   }  
}  



By assigning the values of one object into another
class Student7{  
    int id;  
    String name;  
    Student7(int i,String n){  
    id = i;  
    name = n;  
    }  
    Student7(){}  
    void display(){System.out.println(id+" "+name);}  
   
    public static void main(String args[]){  
    Student7 s1 = new Student7(111,"Karan");  
    Student7 s2 = new Student7();  
    s2.id=s1.id;  
    s2.name=s1.name;  
    s1.display();  
    s2.display();  
   }  
}  


By clone() method of Object class
_______________________________________________________________________________________________________________________________
LOADERS/JVM/JRE/JDK=>
CLASSLOADERS->

Java ClassLoader is an abstract class. It belongs to a java.lang package. 
It loads classes from different resources. Java ClassLoader is used to load the classes at run time. 
In other words, JVM performs the linking process at runtime. 
Classes are loaded into the JVM according to need. If a loaded class depends on another class, that class is loaded as well.
-----------------------------------------------------------------------------------------
Java ClassLoader is based on three principles: Delegation, Visibility, and Uniqueness.

Delegation principle: It forwards the request for class loading to parent class loader. It only loads the class if the 
parent does not find or load the class.
Visibility principle: It allows child class loader to see all the classes loaded by parent ClassLoader. But the parent class 
loader cannot see classes loaded by the child class loader.
Uniqueness principle: It allows to load a class once. It is achieved by delegation principle. 
It ensures that child ClassLoader doesn't reload the class, which is already loaded by the parent.
-----------------------------------------------------------------------------------------
Types of classloaders->
Bootstrap Class Loader: It loads standard JDK class files from rt.jar and other core classes. It is a parent of all class loaders. It doesn't have any parent. When we call String.class.getClassLoader() it returns null, and any code based on it throws NullPointerException. 
It is also called Primordial ClassLoader. It loads class files from jre/lib/rt.jar. For example, java.lang package class.

Extensions Class Loader: It delegates class loading request to its parent. If the loading of a class is unsuccessful, 
it loads classes from jre/lib/ext directory or any other directory as java.ext.dirs. It is implemented by sun.misc.Launcher$ExtClassLoader in JVM.

System Class Loader: It loads application specific classes from the CLASSPATH environment variable. 
It can be set while invoking program using -cp or classpath command line options. 

--------------------------------------------------------------------------------------------
How classloader works->

*When JVM request for a class, it invokes a loadClass() method of the java.lang.ClassLoader class
 by passing the fully classified name of the class. The loadClass() method calls for findLoadedClass() method to check that the class has been already loaded or not.
 It is required to avoid loading the class multiple times.
If the class is already loaded, it delegates the request to parent ClassLoader to load the class. 
If the ClassLoader is not finding the class, it invokes the findClass() method to look for the classes in the file system. The following diagram shows how ClassLoader loads class in Java using delegation.
-------------------------------------------------------------------------------------
It checks if the class is already loaded.
If the class is not loaded, ask parent class loader to load the class.
If parent class loader cannot load class, attempt to load it in this class loader.
*4. Can you implement your own ClassLoader in Java?
Yes,

7. Can you load a class that is not in CLASSPATH?
Yes, it's possible to load classes that are not in Classpath. Since Java Virtual 
Machine itself uses three different ClassLoader: BootStrap, extension, and System 

Read more: https://javarevisited.blogspot.com/2021/05/java-classloader-interview.html#ixzz7yIx4tVfn
*Every ClassLoaders loads .class file from a particular location, BootStrap Classloader
 is responsible for loading System classes and loads the class file from rt.jar,
Classes are statically loaded with "new" operator. Dynamic class loading 
invokes the functions of a class loader at run time by using Class.forName() method.
==================================================*******===================================================
jvm->JVM
JVM (Java Virtual Machine) is an abstract machine. It is called a virtual machine because it doesn't physically exist. 
It is a specification that provides a runtime environment in which Java bytecode can be executed. 
It can also run those programs which are written in other languages and compiled to Java bytecode.

JVMs are available for many hardware and software platforms. JVM, JRE, and JDK are platform dependent because
 the configuration of each OS is different from each other. However, Java is platform independent. 
The JVM performs the following main tasks:

Loads code
Verifies code
Executes code
Provides runtime environment
--------------------------------------------------------------------------
JRE->
JRE is an acronym for Java Runtime Environment. It is also written as Java RTE.
 The Java Runtime Environment is a set of software tools which are used for developing Java applications. It is used to 
provide the runtime environment. It is the implementation of JVM.
 It physically exists. It contains a set of libraries + other files that JVM uses at runtime.
----------------------------------------------------------------------------
JDK
JDK is an acronym for Java Development Kit. The Java Development Kit (JDK) is a software development environment which is used to develop Java applications and applets. It physically exists. It contains JRE + development tools.

JDK is an implementation of any one of the below given Java Platforms released by Oracle Corporation:

Standard Edition Java Platform
Enterprise Edition Java Platform
Micro Edition Java Platform

The JDK contains a private Java Virtual Machine (JVM) and a few other resources such as an interpreter/loader (java), a compiler (javac), an archiver (jar), a do
cumentation generator (Javadoc), etc. to complete the development of a Java Application.
-------------------------------------------------------------------------------
*yes, you can execute Java program with out JDK. But to do that you need JVM. JDK is basically used to compile your code.
 Once you have .class file of your .
java program you don’t need JDK. You simply run your code with JVM.
*If you just want to execute a java program, you can install only JRE. You don't need 
JDK because there is no development or compilation of java source code is required.
=========================================================*******===========================================================
Bytecode and compiler=>
How does it works?
When we write a program in Java, firstly, the compiler compiles that program and a bytecode is generated for that piece of code.
 When we wish to run this .class file on any other platform, we can do so. After the first compilation,
 the bytecode generated is now run by the Java Virtual Machine 
*java bytecode is the instruction set for the Java Virtual Machine. It acts similar to an assembler
*it make java code platform independent.
*bytecodes are non-runnable codes and rely on the availability of an interpreter to execute and thus the JVM comes into play.
*Bytecode is essentially the machine level language which runs on the Java Virtual Machine. Whenever a class is loaded,
 it gets a stream of bytecode per method of the class.
*after compilation . lass file is generated
*The machine-level language is a language that consists of a set of instructions that are in the binary form 0 or 1. 
*What is JIT Compiler?
It is the Just-In-Time Compiler, It complies the similar functionality code also improves the performance.
 It reduces the compilation time as it can compile same functionality code in same time.

Is Java enables high performance and how?
Yes, Java enables the high performance as Java has Just-In-Compiler, 
__________________________________________________________________________________________________________________

OOPS=> 

INHERITANCE=>

Inheritance in Java is a mechanism in which one object acquires all the properties and behaviors of a parent object. It is an important part of OOPs (Object Oriented programming system).

*The idea behind inheritance in Java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of the parent class.

*Inheritance represents the IS-A relationship which is also known as a parent-child relationship.

*Why use inheritance in java
For Method Overriding (so runtime polymorphism can be achieved).
For Code Reusability.

*Reusability: As the name specifies, reusability is a mechanism which facilitates you to reuse the fields and methods of the existing class when you create a new class. You can use the same fields and methods already defined in the previous class.

*class Employee{  
 float salary=40000;  
}  
class Programmer extends Employee{  
 int bonus=10000;  
 public static void main(String args[]){  
   Programmer p=new Programmer();  
   System.out.println("Programmer salary is:"+p.salary);  
   System.out.println("Bonus of Programmer is:"+p.bonus);  
}  
}  


*class Animal{  
void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
void bark(){System.out.println("barking...");}  
}  
class TestInheritance{  
public static void main(String args[]){  
Dog d=new Dog();  
d.bark();  
d.eat();  
}}  

*Multilevel Inheritance Example->
When there is a chain of inheritance, it is known as multilevel inheritance. As you can see in the example given below, BabyDog class inherits the Dog class which again inherits the Animal class,


class Animal{  
void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
void bark(){System.out.println("barking...");}  
}  
class BabyDog extends Dog{  
void weep(){System.out.println("weeping...");}  
}  
class TestInheritance2{  
public static void main(String args[]){  
BabyDog d=new BabyDog();  
d.weep();  
d.bark();  
d.eat();  
}}


*Hierarchical Inheritance Example->
When two or more classes inherits a single class, it is known as hierarchical inheritance.

 class Animal{  
void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
void bark(){System.out.println("barking...");}  
}  
class Cat extends Animal{  
void meow(){System.out.println("meowing...");}  
}  
class TestInheritance3{  
public static void main(String args[]){  
Cat c=new Cat();  
c.meow();  
c.eat();  
//c.bark();//C.T.Error  
}}  


*Multiple inheritance is not supported in Java through class.
To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

Since compile-time errors are better than runtime errors, Java renders compile-time error if you inherit 2 classes. So whether you have same method or different, there will be compile time error.
-----------------------------------------------------------------

practice interview questions->  

*public class C1 {
   int x = 50;
}
public class C2 extends C1 {
   int x = 40;
}
public class Check {
public static void main(String[] args)
{
   C2 c2 = new C2();
   System.out.println(c2.x);
 
   C1 c1 = new C1();
   System.out.println(c1.x);
 
   C1 c3 = new C2();
   System.out.println(c3.x);
  }
}

o/p-> 50,40,40
---------------------------------------------------------------------

20. What does Java's method hiding mean?
Because Java's static methods' method calls are resolved at compile time, they cannot be modified. However, this did not stop you from declaring a method with the same name in a subclass.

In this instance, we say that a static method in the parent class was hidden by a method in the subclass.

*Because overloading is handled at compile time, if a variable in the parent class points to an object in the child class, the parent class's static method will also be called.

*--------------------------------------------------------
Q 21  

public class A
{
   private int x = 50;  
   void m1() {
       System.out.println(x); 
 }
}
public class B extends A {

}
public class Test {
public static void main(String[] args)
{
   A a = new B();
    a.m1();
  }
}

o/p 50
-------------------------------------------------------------------------
Q  public class A
{
   private int x = 50;  
   void m1() {
       System.out.println(x); 
 }
}
public class B extends A {

}
public class Test {
public static void main(String[] args)
{
   A a = new B();
    a.m1();
  }
}

o/p 50
----------------------------------------------
Q  

------------------------------------------****-----------------------------------------------------------
    equals and hashcode code for overriding->

*The equals() and hashcode() are the two important methods provided by the Object class for comparing objects. Since the Object class is the parent class for all Java objects

equals()=>The java equals() is a method of lang.Object class, and it is used to compare two objects.
To compare two objects that whether they are the same, it compares the values of both the object's attributes.
By default, two objects will be the same only if stored in the same memory location.

hashcode->A hashcode is an integer value associated with every object in Java, facilitating the hashing in hash tables.
To get this hashcode value for an object, we can use the hashcode() method in Java. It is the means hashcode()
method that returns the integer hashcode value of the given object.

* hashcode() method that returns the integer hashcode value of the given object.

*The hashcode() method returns the same hash value when called on two objects, which are equal according to the equals() method. And if the objects are unequal, it usually returns different hash values.

*Contract for hashcode() method in Java
If two objects are the same as per the equals(Object) method, then if we call the hashCode() method on each of the two objects, it must provide the same integer result.

@Override
    public int hashCode()
    {
           
       
        return this.id;
    }


Note: As per the Java documentation, both the methods should be overridden to get the complete equality mechanism; using equals() alone is not sufficient. It means, if we override the equals(), we must override the hashcode() method

*It is perfectly legal for two objects to have the same hashcode. If two objects are equal (using the equals() method) then they have the same hashcode. If two objects are not equal then they cannot have the same hashcode.

*To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

Since compile-time errors are better than runtime errors, Java renders compile-time error if you inherit 2 classes. So whether you have same method or different, there will be compile time error.
                                   
class A{  
void msg(){System.out.println("Hello");}  
}  
class B{  
void msg(){System.out.println("Welcome");}  
}  
class C extends A,B{//suppose if it were  //compile time error
   
 public static void main(String args[]){  
   C obj=new C();  
   obj.msg();//Now which msg() method would be invoked?  
}  
}


---------------------------------------------------------------------------------
C1 c3 = new C2();
   System.out.println(c3.x);
in that scenario parent value will be print
=========================================================

class A
{
    {
        System.out.println(1);
    }
}
 
class B extends A
{
    {
        System.out.println(2);
    }
}
 
class C extends B
{
    {
        System.out.println(3);
    }
}
 
public class MainClass
{
    public static void main(String[] args)
    {
        C c = new C();
    }
}
==================================================

*we cannot change overrided method return type
*we can change return type in method overloading
=================================================
 Child c = new Child();
	        Parent2 p2=new Parent2();
	        p2=c;
	        c.tester();
	        p2.tester();//here child method is called

 Parent2 p2=new Parent2();
	        Parent p=new Parent();
	       p2=p;
	        p=p2;
*here parent and parent2 are ubrelated so its showing error
=======================================
____________________________________________

_____________________________________________________________________________________
JAVA8 FEATURES=>
method reffrence ->
*Method reference is used to refer method of functional interface. It is compact and easy form of lambda expression. 
Each time when you are using lambda expression to just referring a method, you can replace your lambda expression with 
method reference
*It is special type of lambda expression and it is used to create lambda expression by reffering existing method.
*we can reuse the code of method.
---------------------------------------------------------------------------------------------
Reference to a Static Method=>

You can refer to static method defined in the class. Following is the 
syntax and example which describe the process of referring static method in Java.
interface Sayable{  
    void say();  
}  
public class MethodReference {  
    public static void saySomething(){  
        System.out.println("Hello, this is static method.");  
    }  
    public static void main(String[] args) {  
        // Referring static method  
        Sayable sayable = MethodReference::saySomething;  
        // Calling interface method  
        sayable.say();  
    }  
}  

class Arithmetic{  
public static int add(int a, int b){  
return a+b;  
}  
}


public class MethodReference4 {  
public static void main(String[] args) {  
BiFunction<Integer, Integer, Integer>adder1 = Arithmetic::add; 
int result1 = adder1.apply(10, 20);  
System.out.println(result1);  }}


*Reference to an Instance Method
like static methods, you can refer instance methods also.

interface Sayable{  
    void say();  
}  
public class InstanceMethodReference {  
    public void saySomething(){  
        System.out.println("Hello, this is non-static method.");  
    }  
    public static void main(String[] args) {  
        InstanceMethodReference methodReference = new InstanceMethodReference(); // Creating object  
        // Referring non-static method using reference  
            Sayable sayable = methodReference::saySomething;  
        // Calling interface method  
            sayable.say();  }}


Reference to a Constructor->
You can refer a constructor by using the new keyword. Here, we are referring constructor with the help of functional interface.
interface Messageable{  
    Message getMessage(String msg);  
}  
class Message{  
    Message(String msg){  
        System.out.print(msg);  
    }  
}  
public class ConstructorReference {  
    public static void main(String[] args) {  
        Messageable hello = Message::new;  
        hello.getMessage("Hello");  
    }  
}  

============================================================********============================================================
Optional Class->
*Java introduced a new class Optional in jdk8. It is a public final class and used to deal with NullPointerException in Java application. You must import java.util package to use this class.
 It provides methods which are used to check the presence of value for particular variable.


public static <T> Optional<T> empty()	              It returns an empty Optional object. No value is present for this Optional.
public static <T> Optional<T> of(T value)	       It returns an Optional with the specified present non-null value.
public static <T> Optional<T> ofNullable(T value)	 It returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.
public T get()	If a value is present in this Optional,   returns the value, otherwise throws NoSuchElementException.
public boolean isPresent()	                          It returns true if there is a value present, otherwise false.
public void ifPresent(Consumer<? super T> consumer)	  If a value is present, invoke the specified 
                                                           consumer with the value, otherwise do nothing.
-----------------------------------------------------------------
without optional->
public class OptionalExample {  
    public static void main(String[] args) {  
        String[] str = new String[10];  
        String lowercaseString = str[5].toLowerCase();  
        System.out.print(lowercaseString);  
    }  
}  

op=>nullpointerexception

with optional=>

public class OptionalExample {  
    public static void main(String[] args) {  
        String[] str = new String[10];  
        Optional<String> checkNull = Optional.ofNullable(str[5]);  
        if(checkNull.isPresent()){  // check for value is present or not  
            String lowercaseString = str[5].toLowerCase();  
            System.out.print(lowercaseString);  
        }else  
            System.out.println("string value is not present");  
    }  
}  
=============================================================*******============================================================
date and time api->

*Java provide the date and time functionality with the help of two packages java.time and java.util. 
The package java.time is introduced in Java 8, 
and the newly introduced classes tries to overcome the shortcomings of the legacy java.util.Date and java.util.Calendar classes.

Thread safety: The existing classes such as Date and Calendar does not provide thread safety. 
Hence it leads to hard-to-debug concurrency issues that are needed to be taken care by developers. 
The new Date and Time APIs of Java 8 provide thread safety and are immutable, 
hence avoiding the concurrency issue from developers.

Bad API designing: The classic Date and Calendar APIs does not provide methods to perform basic day-to-day
 functionalities. The Date and Time classes introduced in Java 8 are ISO-centric and provides 
number of different methods for performing operations regarding date, time, duration and periods.


java.time.LocalDate: It represents a year-month-day in the ISO calendar and is useful for representing a date without a time. It can be used to represent a date only information such as a birth date or wedding date.

java.time.LocalTime: It deals in time only. It is useful for representing human-based time of day, such as movie times, or the opening and closing times of the local library.

java.time.LocalDateTime: It handles both date and time, without a time zone. It is a combination of LocalDate with LocalTime.

java.time.ZonedDateTime: It combines the LocalDateTime class with the zone information given in ZoneId class. It represent a complete date time stamp along with timezone information.

java.time.OffsetTime: It handles time with a corresponding time zone offset from Greenwich/UTC, without a time zone ID.

=============================================================*******============================================================
default and static method in intrface->

*Java provides a facility to create default methods inside the interface. Methods which are defined inside the 
interface and tagged with default are known as default methods.

interface Sayable{  
    // Default method   
    default void say(){  
        System.out.println("Hello, this is default method");  
    }  
    // Abstract method  
    void sayMore(String msg);  
}  
public class DefaultMethods implements Sayable{  
    public void sayMore(String msg){        // implementing abstract method   
        System.out.println(msg);  
    }  
    public static void main(String[] args) {  
        DefaultMethods dm = new DefaultMethods();  
        dm.say();   // calling default method  
        dm.sayMore("Work is worship");  // calling abstract method  
  
    }  
}  


-------------------------------------------------------------------------------
some sceenarios=>*if we create default method in interface then only calling possible like
T is a interface
T t=new A();
	 t.printer();

*If we have default method in parent and also same name method 
in child class without default because we cannot create default in a aclass
T t=new A();
	 t.printer();//child method will call
*if we override default method in child class then return type cannot be change because its ovrrided
*is we create static method in both interface and child class then if we call using interface 
ref then interface static method will called.
---------------------------------------------------------------------------------------------
Why Interfaces Need Default Methods
Like regular interface methods, default methods are implicitly public; there's no need to specify the public modifier.

Unlike regular interface methods, we declare them with the default keyword at the beginning of the method signature,
 and they provide an implementation.

*Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.
 A static method is a method that is associated with the class in which it is defined rather than with any object
=============================================================*******============================================================
lembda expression and functional interface->
lambda expression->*lambda expression is a concise representation of anonyms function that can be passed arround ,it does not have 
 a name ,
anonyms->does not have name
concise->no need to write bilorplate code
passed arround-> lambda ex can be passed as an args to the method or stored in a  variable.

*It provides a clear and concise way to represent one method interface using an expression. It is very useful in collection library. 
It helps to iterate, filter and extract data from collection.

*The Lambda expression is used to provide the implementation of an interface which has functional interface. 
It saves a lot of code. In case of lambda expression, we don't need to define the method again for providing the implementation.
 Here, we just write the implementation code.

*Lambda expression provides implementation of functional interface. 
An interface which has only one abstract method is called functional interface. Java provides an anotation @FunctionalInterface,
 which is used to declare an interface as functional interface.

*1) Argument-list: It can be empty or non-empty as well.

2) Arrow-token: It is used to link arguments-list and body of expression.

3) Body: It contains expressions and statements for lambda expression.
--------------------------------------------------------------------------------------
Without Lambda Expression
interface Drawable{  
    public void draw();  
}  
public class LambdaExpressionExample {  
    public static void main(String[] args) {  
        int width=10;  
  
        //without lambda, Drawable implementation using anonymous class  
        Drawable d=new Drawable(){  
            public void draw(){System.out.println("Drawing "+width);}  
        };  
        d.draw();  
    }  
}  
---------------------------------------------------------------
@FunctionalInterface  //It is optional  
interface Drawable{  
    public void draw();  
}  
  
public class LambdaExpressionExample2 {  
    public static void main(String[] args) {  
        int width=10;  
          
        //with lambda  
        Drawable d2=()->{  
            System.out.println("Drawing "+width);  
        };  
        d2.draw();  
    }  
}  

*A lambda expression can be used in a return statement. The return type of the method in 
which a lambda expression is used in a return statement must be a functional interface.
---------------------------------------------------------------
Java Lambda Expression Example: Single Parameter
interface Sayable{  
    public String say(String name);  
}  
  
public class LambdaExpressionExample4{  
    public static void main(String[] args) {  
      
        // Lambda expression with single parameter.  
        Sayable s1=(name)->{  
            return "Hello, "+name;  
        };  
        System.out.println(s1.say("Sonoo"));  
          
        // You can omit function parentheses    
        Sayable s2= name ->{  
            return "Hello, "+name;  
        };  
        System.out.println(s2.say("Sonoo"));  
    }  
} 
----------------------------------------------------------------------------
Addable ad1=(a,b)->(a+b);  
        System.out.println(ad1.add(10,20));  
------------------------------------------------------------------- 
@FunctionalInterface  
interface Sayable{  
    String say(String message);  
}  
  
public class LambdaExpressionExample8{  
    public static void main(String[] args) {  
      
        // You can pass multiple statements in lambda expression  
        Sayable person = (message)-> {  
            String str1 = "I would like to say, ";  
            String str2 = str1 + message;   
            return str2;  
        };  
            System.out.println(person.say("time is precious."));  
    }  
}  
-------------------------------------------------------------------
List<String> list=new ArrayList<String>();  
        list.add("ankit");  
        list.add("mayank");  
        list.add("irfan");  
        list.add("jai");  
          
        list.forEach(  
            (n)->System.out.println(n)  
        );  
    }  
------------------------------------------------------------------
@FunctionalInterface  
interface Sayable{  
    String say(String message);  
}  
  
public class LambdaExpressionExample8{  
    public static void main(String[] args) {  
      
        // You can pass multiple statements in lambda expression  
        Sayable person = (message)-> {  
            String str1 = "I would like to say, ";  
            String str2 = str1 + message;   
            return str2;  
        };  
            System.out.println(person.say("time is precious."));  
    }  
}  
------------------------------------------------------------------
public class LambdaExpressionExample10{  
    public static void main(String[] args) {  
        List<Product> list=new ArrayList<Product>();  
          
        //Adding Products  
        list.add(new Product(1,"HP Laptop",25000f));  
        list.add(new Product(3,"Keyboard",300f));  
        list.add(new Product(2,"Dell Mouse",150f));  
          
        System.out.println("Sorting on the basis of name...");  
  
        // implementing lambda expression  
        Collections.sort(list,(p1,p2)->{  
        return p1.name.compareTo(p2.name);  
        });  
        for(Product p:list){  
            System.out.println(p.id+" "+p.name+" "+p.price);  
        }  
  
    }  
}  
----------------------------------------------------------------------
Stream<Product> filtered_data = list.stream().filter(p -> p.price > 20000);  
          
        // using lambda to iterate through collection  
        filtered_data.forEach(  
                product -> System.out.println(product.name+": "+product.price)  
        );  
------------------------------------------------------------------------------
predefined functional interface=>  

 *  Predicate<Integer,Intrtger>=>It represents a predicate (boolean-valued function) of one argument.test()
*   Function<T>=>It represents a function that accepts one argument and returns a result.apply()
*   Consume<T>=>It represents an operation that accepts a single argument and returns no result.accept()
*  Supplier<T>	=>It represents a supplier of results.no take any args get()

--------------------------------------------------------------------------------
  interview questions=> *2. Can you pass lambda expression to a method? When? (answer)
Yes, you can pass a lambda expression to a method provided it is expecting a functional interface.
static List<String> method(BiFunction<Integer, String, List<String>> fn){
    return fn.apply(5, "FooBar");
  }


7. Can you local variables inside lambda expressions in Java 8? (answer)
Yes, you can use local variable inside lambda expression but only which are effectively final variables. This rule is same as the local variable used inside Anonymous class.
 If you remember, we can only use final local variables inside anonymous class.  

9. Can you name some common functional interface of JDK 8? (answer)
Even though you can name Comparator, Comparable, Runnable, Callable, or EventListener as functional interface, it's better to name new functional interfaces from java.util.function pacakge like Predicate, Consumer, Supplier, or BinaryFunction. 


13. What is difference between lambda expression and anonymous class in Java 8? (answer)
Even though both lambda expression and anonymous class server the same purpose of passing code to a method there is 
a key difference between them from Java perspective. 

An anonymous class is a class while lambda expression is more like anonymous function. You can also pass the Lambda
 expression to any method which accept a functional interface, I mean those interface which just have one single abstract
 method but you can pass anonymous class to any method which accept any class,


14. Can you write more than one line of code in lambda expression? (answer)
Yes, you can write more than online of code in lambda expression using curly braces, similar to how you define static initializer block. 

Here is an example of lambda expression which is longer than one line:

(String first, String second) -> { 
if(first.equals(second)){ 
   return true; 
 }else{ 
   return false; 
 } 
};


               
=============================================================*******=============================================================
STREAM API =>*  Java provides a new additional package in Java 8 called java.util.stream. 
             This package consists of classes, interfaces 

*Stream does not store elements. It simply conveys elements from a source such as a data structure, an array, or an I/O channel, 
through a pipeline of computational operations.
*Stream is functional in nature. Operations performed on a stream does not modify it's source. For example,
 filtering a Stream obtained from a collection produces a
 new Stream without the filtered elements, rather than removing elements from the source collection.
Stream is lazy and evaluates code only when required.
The elements of a stream are only visited once during the life of a stream. Like an Iterator, a new stream must be generated to revisit the same elements of the source.

*You can use stream to filter, collect, print, and convert from one data structure to other etc
-----------------------------------------------------------------------------------
Methods=>

1>   boolean allMatch(Predicate<? super T> predicate)
2>   boolean anyMatch(Predicate<? super T> predicate)
3>   <R,A> R collect(Collector<? super T,A,R> collector)
4>   static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
5>   long count()
6>   Stream<T> distinct()
7>   static <T> Stream<T> empty()
8>   Stream<T> distinct()
9>   static <T> Stream<T> empty()
10>  Stream<T> filter(Predicate<? super T> predicate)
11>  Optional<T> findAny()
12>  Optional<T> findFirst()
13>  <R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
14>   DoubleStream flatMapToDouble(Function<? super T,? extends DoubleStream> mapper)
15>   void forEach(Consumer<? super T> action)
16>   static <T> Stream<T> generate(Supplier<T> s)
17>   

--------------------------------------------------------------------------
logical questions->

Query 3.1 : How many male and female employees are there in the organization?
            employeeList.stream().collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));

Query 3.2 : Print the name of all departments in the organization?
            employeeList.stream().map(Employee::getDepartment).distinct().forEach(System.out::println);

Query 3.3 : What is the average age of male and female employees?
            Map<String, Double> avgAgeOfMaleAndFemaleEmployees=
         employeeList.stream().collect(Collectors.groupingBy(Employee::getGender, Collectors.averagingInt(Employee::getAge)));

Query 3.4 : Get the details of highest paid employee in the organization?
             Optional<Employee> highestPaidEmployeeWrapper=
           employeeList.stream().collect(Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary)));

Query 3.5 : Get the names of all employees who have joined after 2015?
            employeeList.stream().filter(e -> e.getYearOfJoining() > 2015) .map(Employee::getName) .forEach(System.out::println);

Query 3.6 : Count the number of employees in each department?
             Map<String, Long> employeeCountByDepartment=
employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));
       

Query 3.7 : What is the average salary of each department?
           Map<String, Double> avgSalaryOfDepartments=
employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment, Collectors.averagingDouble(Employee::getSalary)));
    

Query 3.8 : Get the details of youngest male employee in the product development department?
               Optional<Employee> youngestMaleEmployeeInProductDevelopmentWrapper=
employeeList.stream() .filter(e -> e.getGender()=="Male" && e.getDepartment()=="Product Development")
.min(Comparator.comparingInt(Employee::getAge));

Query 3.9 : Who has the most working experience in the organization?
           Optional<Employee> seniorMostEmployeeWrapper=
employeeList.stream().sorted(Comparator.comparingInt(Employee::getYearOfJoining)).findFirst();

Query 3.10 : How many male and female employees are there in the sales and marketing team?

      Map<String, Long> countMaleFemaleEmployeesInSalesMarketing=employeeList.stream() .
filter(e -> e.getDepartment()=="Sales And Marketing").collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));

Query 3.11 : What is the average salary of male and female employees?

     Map<String, Double> avgSalaryOfMaleAndFemaleEmployees=
employeeList.stream().collect(Collectors.groupingBy(Employee::getGender, Collectors.averagingDouble(Employee::getSalary)));
  

Query 3.12 : List down the names of all employees in each department?
           
           Map<String, List<Employee>> employeeListByDepartment=
      employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment));
         
Set<Entry<String, List<Employee>>> entrySet = employeeListByDepartment.entrySet();

Query 3.13 : What is the average salary and total salary of the whole organization?
             DoubleSummaryStatistics employeeSalaryStatistics=
             employeeList.stream().collect(Collectors.summarizingDouble(Employee::getSalary));

Query 3.14 : Separate the employees who are younger or equal to 25 years from those employees who are older than 25 years.

Map<Boolean, List<Employee>> partitionEmployeesByAge=
employeeList.stream().collect(Collectors.partitioningBy(e -> e.getAge() > 25));
         
Query 3.15 : Who is the oldest employee in the organization? What is his age and which department he belongs to?
             Optional<Employee> oldestEmployeeWrapper = employeeList.stream().max(Comparator.comparingInt(Employee::getAge));
--------------------------------------------------------------
interview questions=> max()=>Product productA = productsList.stream()
            .max((product1, product2) -> product1.getPrice() > product2.getPrice() ? 1 : -1).get();

min()=>Product productB = productsList.stream()
            .max((product1, product2) -> product1.getPrice() < product2.getPrice() ? 1 : -1).get();
     
create stream from array=>  Stream<String> streamOfArray = Stream.of("a", "b", "c");
                         streamOfArray.forEach(System.out::println);

List<String> result = lines.stream()       // convert list to stream
                .filter(line -> !"c".equals(line)) // we dont like c
                .collect(Collectors.toList());     // collect the output and convert streams to a List

        result.forEach(System.out::println);  

List < Product > filteredProducts = getProducts().stream()
            .filter((product) -> product.getPrice() > 25000 f)
            .collect(Collectors.toList());



difference b/w map and flatmap->   The function you pass to the map() operation returns a single value.
The function you pass to flatMap() operation returns a Stream of value.
flatMap() is a combination of map and flat operation.
map() is used for transformation only, but flatMap() is used for both transformation and flattening.
         

sorting in reverse order =>
list.stream().sorted(Comparator.reverseOrder()).
                          forEach(System.out::println);


 List<Human> humans = Lists.newArrayList(new Human("Sarah", 10), new Human("Jack", 12));
    Comparator<Human> nameComparator = (h1, h2) -> h1.getName().compareTo(h2.getName());
	
    List<Human> sortedHumans = 
      humans.stream().sorted(nameComparator).collect(Collectors.toList());

_________________________________________________________________________________________________________________________________

COLLECTION=>

*The Collection in Java is a framework that provides an architecture to store and manipulate the group of objects.

*Java Collections can achieve all the operations that you perform on a data such as searching, sorting, insertion, manipulation, and deletion.

*Java Collection means a single unit of objects. Java Collection framework provides many interfaces 
(Set, List, Queue, Deque) and classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet).

*What is Collection in Java
A Collection represents a single unit of objects, i.e., a group.

*What is a framework in Java
It provides readymade architecture.
It represents a set of classes and interfaces.
It is optional.

*What is Collection framework
The Collection framework represents a unified architecture for storing and manipulating a group of objects. It has:
Interfaces and its implementations, i.e., classes
Algorithm

*The java.util package contains all the classes and interfaces for the Collection framework.

hirarchy=>


                                                Iterabel
                                                    
                                                  |

                                                 Collection
                                                    |
       List                                         Set                                              Queue
ArrayList,LinkedList,Vector ,stack                   
                                               |
                                         |                   Hashset                                      |
                                         SortedSet            |                                         Priorityqueue
                                            |                  LinkedHashSet
                                           TreeSet



Iterable->
 The Iterable interface is the root interface for all the collection classes. The Collection interface extends 
the Iterable interface and therefore all the subclasses of Collection interface also implement the Iterable interface.
It contains only one abstract method. i.e.,

Iterator<T> iterator()  
It returns the iterator over the elements of type T.

Collection Interface
The Collection interface is the interface which is implemented by all the classes in the collection framework. 
It declares the methods that every collection will have. 
In other words, we can say that the Collection interface builds the foundation on which the collection framework depends.
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
List->List interface is the child interface of Collection interface. It inhibits a list type data structure
 in which we can store the ordered collection of objects. It can have duplicate values.
List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack.


Arraylist->
*The ArrayList class implements the List interface. It uses a dynamic array to store the duplicate  element of different data types. 
The ArrayList class maintains the insertion order and is non-synchronized. 
*Its initial size is 10 when we exide size it will increase 1/2  & also contain null values

class TestJavaCollection1{  
public static void main(String args[]){  
ArrayList<String> list=new ArrayList<String>();//Creating arraylist  
list.add("Ravi");//Adding object in arraylist  
list.add("Vijay");  
list.add("Ravi");  
list.add("Ajay");  
for(String s:list){sop(list)}
}  
}  
}  
The elements stored in the ArrayList class can be randomly accessed. Consider the following example.

LinkedList->

LinkedList implements the Collection interface. It uses a doubly linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.

Consider the following example.

import java.util.*;  
public class TestJavaCollection2{  
public static void main(String args[]){  
LinkedList<String> al=new LinkedList<String>();  
al.add("Ravi");  
al.add("Vijay");  
al.add("Ravi");  
al.add("Ajay");  
for(String s:list){sop(list)}
}  
}  
}


 LinkedList<String> list = new LinkedList<String>();
		  
	        // use add() method to add elements in the list
	        list.add("Geeks");
	        list.add("for");
	        list.add("Geeks");
	        list.add("10");
	        list.add("20");
	        list.addFirst("ty");
	        list.addLast("uy");
	        list.addLast("er");
	        list.addFirst("ab");
	        System.out.println(list);

op=>[ab, ty, Geeks, for, Geeks, 10, 20, uy, er]


vector->

Vector uses a dynamic array to store the data elements. It is similar to ArrayList. However, 
It is synchronized and contains many methods that are not the part of Collection framework.
*it is slow

Consider the following example.

import java.util.*;  
public class TestJavaCollection3{  
public static void main(String args[]){  
Vector<String> v=new Vector<String>();  
v.add("Ayush");  
v.add("Amit");  
v.add("Ashish");  
v.add("Garima");  
Iterator<String> itr=v.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  

stack->
The stack is the subclass of Vector. It implements the last-in-first-out data structure, 
i.e., Stack. The stack contains all of the methods of Vector class and also provides its methods like boolean push(), 
boolean peek(), boolean push(object o), which defines its properties.

public class TestJavaCollection4{  
public static void main(String args[]){  
Stack<String> stack = new Stack<String>();  
stack.push("Ayush");  
stack.push("Garvit");  
stack.push("Amit");  
stack.push("Ashish");  
stack.push("Garima");  
stack.pop();  
Iterator<String> itr=stack.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  

*The peek() method is used to look at the object at the top of this stack without removing it from the stack.
*The pop() method is used to look at the object at the top of this stack with removing it from the stack.
-------------------------------------------------------------------------------------------
Q why vector and stack is not used

vector->
*Vector synchronizes on each individual operation. That's almost never what you want to do.
Generally you want to synchronize a whole sequence of operations. Synchronizing individual

1) You can achieve Thread Safety without Vector.
Vector class has only one advantage over ArrayList i.e it is thread safety. But,
 you can achieve thread safe ArrayList by using synchronizedList() method of Collections class. Below is the sample code.
  ArrayList<Integer> list = new ArrayList<Integer>();
  Collections.synchronizedList(list);

2) Thread Safeness of Vector class is time consuming.
All methods of Vector class are synchronized. This makes each and every operation on Vector object thread safe. But, it is time consuming. 

3) Enumeration Vs Iterator
Vector class has a method which return Enumeration over the elements of Vector object. Although,
 Enumerations are faster than the Iterator, but it is not backed by the original collection. That means, any changes made to original collection
 does not reflect in Enumeration object. They ignore the modifications done during iteration. This may cause issues.

4) Is Vector class poorly designed?
Vector class combines two features – “Re-sizable Array” and “Synchronization“. This makes poor design. Because, 
if you need just “Re-sizable Array” and you use Vector class for that, you will get “synchronized Resizable Array” not just re-sizable array. 
This may reduce the performance of your application. 
Therefore, instead of using Vector class, always use ArrayList class.

stack->
----------------------------------------------------------------------------------------
Q.why arraylist is better for access  and linkedlist for modification.
ArrayLists use contiguous memory. All elements in the ArrayList are located next to each other in the same memory space.
* This is why retrieving an element from an ArrayList is so fast: 
*This is why retrieving an element from an ArrayList is so fast: 
System.out.println(list.get(1))


*Linked list uses runtime allocation of memory resulting in no wastage of memory space.

 --------------------------------------------------------------------------------------
Q diff between arraylist and linkedlist 

ArrayList	                                                                                                   LinkedList

1) ArrayList internally uses a dynamic array to store the elements.	               |      LinkedList internally uses a doubly linked list to store the elements.

2) Manipulation with ArrayList is slow because it internally uses an array If                  Manipulation with LinkedList is faster than ArrayList because it uses a 
any element is removed from the array, all the other elements are shifted in memory.          doubly linked list, so no bit shifting is required in memory.
	
3) An ArrayList class can act as a list only because it implements List only.	             LinkedList class can act as a list and queue both because it implements List and Deque interface

4) ArrayList is better for storing and accessing data.                                   	LinkedList is better for manipulating data.
5) The memory location for the elements of an ArrayList is contiguous.	                      The location for the elements of a linked list is not contagious.

6) Generally, when an ArrayList is initialized, a default capacity of 10 is                 There is no case of default capacity in a LinkedList. In LinkedList,
assigned to the ArrayList.	                                                             an empty list is created when a LinkedList is initialized.

7) To be precise, an ArrayList is a resizable array.	                              LinkedList implements the doubly linked list of the list interface.


---------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------******---------------------------------------------------

Set->

The set is an interface available in the java.util package. The set interface extends the Collection interface. An unordered collection or list in which duplicates are not allowed is referred to as a collection interface. The set interface is used to create the mathematical set. The set interface use collection interface's methods to avoid the insertion of the same elements. SortedSet and NavigableSet are two interfaces that extend the set implementation.

public static void main(String[] args)  
    {  
        // creating LinkedHashSet using the Set  
        Set<String> data = new LinkedHashSet<String>();  
   
        data.add("JavaTpoint");  
        data.add("Set");  
        data.add("Example");  
        data.add("Set");  
   
        System.out.println(data);  
    }  
o/p=size 3

*it contain null values
---------------------------------------------------------------------
hashset internal working->  

*HashSet uses HashMap internally in Java.
*When we create an object of HashSet, it internally creates an instance of HashMap with
default initial capacity 16.
*HashSet uses a constructor HashSet(int capacity) that represents how many elements
 can be stored in the HashSet. The capacity may increase automatically when more elements to be store.
*HashSet uses another constructor HashSet(int capacity, float loadfactor). Here, loadfactor demines the 
point where the capacity of HashSet would be increased internally. For example, the product of capacity 
and loadfactor is 101*0.5=50.5.
*we are implementing add() method which adds element into HashSet.
*We can observe that duplicate values are not stored in the HashSet. When we pass duplicate elements in the add() 
method of the Set object, it internally returns false.
*Here, a question arises that how it returns false. When we open the HashSet implementation of the add() method in Java APIs
public class HashSet<E> extends AbstractSet<E>  
{  
private transient HashMap<E,Object> map;  
// Dummy value to associate with an Object in the backing Map  
private static final Object PRESENT = new Object();  
public HashSet()  
{  
map = new HashMap<>();  
}  
public boolean add(E e)  
{  
return map.put(e, PRESENT)==null;  
}  
}  

*In the above code a call to add(object) is delegated to put(key, value) internally.
Where key is the object we have passed and the value is another object, called PRESENT. It is a constant in java.util.HashSet.

*We are achieving uniqueness in Set internally through HashMap. When we create an object of HashSet,
 it will create an object of HashMap. We know that each key is unique in the HashMap. 
So, we pass the argument in the add(E e) method. Here, we need to associate some value to the key.
 It will associate with Dummy value that is (new Object()) which is referred by Object reference PRESENT.

*When we add an element in HashSet like hs.add("India"), Java does internally is that it will put that element E here
 "India" as a key into the HashMap (generated during HashSet object creation).
 It will also put some dummy value that is Object's object is passed as a value to the key.

*The important points about put(key, value) method is that:
If the Key is unique and added to the map, then it will return null
If the Key is duplicate, then it will return the old value of the key.

*If the method map.put(key, value) returns null, then the method map.put(e, PRESENT)==null will return true internally, and the element added to the HashSet.
If the method map.put(key, value) returns the old value of the key, then the method map.put(e, PRESENT)==null will return false internally, and the element will not add to the HashSet.

---------------------------------------------------------
LinkedHashSet->
*It will main insersion order.
*It contain null value
---------------------------------------------------------
treeset->

*Java TreeSet class implements the Set interface that uses a tree for storage. 
It inherits AbstractSet class and implements the NavigableSet interface. 
The objects of the TreeSet class are stored in ascending order.

*Java TreeSet class contains unique elements only like HashSet.
*Java TreeSet class access and retrieval times are quiet fast.
*Java TreeSet class doesn't allow null element.
*Java TreeSet class is non synchronized.
*Java TreeSet class maintains ascending order.
*TreeSet is being implemented using a binary search tree, which is self-balancing just like a Red-Black Tree. Therefore, operations such as a search, remove, and add consume O(log(N)) time.
*its synchronization
TreeSet treeSet = new TreeSet();  
Set syncrSet = Collections.synchronziedSet(treeSet);

*The TreeSet can only allow those generic types that are comparable. For example The Comparable interface

public class Tester  {
      
      public static void main(String[] args) {
      Student s1=new Student(2,23,"sweta");
      Student s2=new Student(1,11,"mango");
      TreeSet<Student> tree=new TreeSet<>();
      tree.add(s1);
      tree.add(s2);
      System.out.println(tree);
      }
}


o/p=>d "main" java.lang.ClassCastException: corejavaapp.Student cannot be cast to java.lang.Comparable
      at java.util.TreeMap.compare(TreeMap.java:1294)

solution=>

public class Student implements Comparable<Student>{
private int id;
private int age;
private String name;
public int getId() {
      return id;
}
public void setId(int id) {
      this.id = id;
}
public int getAge() {
      return age;
}
public void setAge(int age) {
      this.age = age;
}
public String getName() {
      return name;
}
public void setName(String name) {
      this.name = name;
}
public Student(int id, int age, String name) {
      super();
      this.id = id;
      this.age = age;
      this.name = name;
}
@Override
public int compareTo(Student o) {
      // TODO Auto-generated method stub
      return this.id-o.getId();
}
@Override
public String toString() {
      return "Student [id=" + id + ", age=" + age + ", name=" + name + ", getId()=" + getId() + ", getAge()=" + getAge()
                  + ", getName()=" + getName() + "]";
}

}


public class Tester   {
      
      public static void main(String[] args) {
      Student s1=new Student(2,23,"sweta");
      Student s2=new Student(1,11,"mango");
      TreeSet<Student> tree=new TreeSet<>();
      TreeSet<String> tree2=new TreeSet<>();
      tree2.add("hi");
      tree.add(s1);
      tree.add(s2);
for(Student s:tree) {
System.out.println(s);
      }}

      
}

*System.out.println(tree.comparator());//null
      


mehods->
  boolean contains(Object o)              It returns true if this set contains the specified element.
boolean isEmpty()                    It returns true if this set contains no elements.
boolean remove(Object o)                It is used to remove the specified element from this set if it is present.
void clear()                            It is used to remove all of the elements from this set.
Object clone()                        It returns a shallow copy of this TreeSet instance.
E first()                           It returns the first (lowest) element currently in this sorted set.
Comparator<? super E> comparator()     It returns a comparator that arranges elements in order.
Iterator descendingIterator()              It is used to iterate the elements in descending order.
-------------------------------------------------------**--------------------------------------------------------
Enumeration->

*java.util.Enumeration interface is one of the predefined interfaces, whose object is
used for retrieving the data from collections framework variable( like Stack, Vector, HashTable etc.) 
in a forward direction only and not in the backward direction.


*List<String> arrlist = new ArrayList<String>();

// Adding element to srclst
arrlist.add("Ram");
arrlist.add("Gopal");
arrlist.add("Verma");

// Print the list
System.out.println("List: " + arrlist);

// creating object of type Enumeration<String>
Enumeration<String> e = Collections.enumeration(arrlist);

// Print the Enumeration
System.out.println("\nEnumeration over list: ");

// print the enumeration
while (e.hasMoreElements())
    System.out.println("Value is: " + e.nextElement());
arrlist.add("a");
for(String s:arrlist) {
      System.out.println(s);
}
}
-----------------------------------------------------------------****-----------------------------------------
Map->
  *A map contains values on the basis of key, i.e. key and value pair.
Each key and value pair is known as an entry. A Map contains unique keys.

*A Map is useful if you have to search, update or delete elements on the basis of a key.
*getKey().getValue(),setValue() is not a methods of map.

                                                         Map
                                                          |
                               sortedmap                                   Hashmap
                                   |                                          |
                                  TreeMap                                    LinkedHashMap

--------------------------------------------------------------------------------------------------------
HashMap->
      * HashMap and LinkedHashMap allow one null keys and values
*it has only unique keys.
     *A Map can't be traversed, so you need to convert it into Set using keySet() or entrySet() method.
*It can have duplicate values
*it uses hashing technique to inject the data using put method.
*it is not synchronized  
*it doesn't maintain any order.

methods->

V put(Object key, Object value)                                          It is used to insert an entry in the map.
void putAll(Map map)                                               It is used to insert the specified map in the map.
V putIfAbsent(K key, V value)                          It inserts the specified value with the specified key in the                                                            map only if it is not already specified.
V remove(Object key)                                       It is used to delete an entry for the specified key.
boolean remove(Object key, Object value)           It removes the specified values with the associated                                                           specified keys from the map.
Set keySet()                                              It returns the Set view containing all the keys.

Set<Map.Entry<K,V>> entrySet()                                It returns the Set view containing all the keys and values.
void clear()                                                  It is used to reset the map.

V compute(K key, BiFunction<? super K,? super V,             It is used to compute a mapping for the specified
? extends V> remappingFunction)                           key and its current mapped value (or null if there is no                                                         current mapping).

V computeIfAbsent(K key, Function<? super K,        It is used to compute its value using the given mapping function,
? extends V> mappingFunction)                    if the specified key is not already associated with
                                             a value (or is mapped to null), and enters it into this map unless null.

V computeIfPresent(K key, BiFunction<? s               It is used to compute a new mapping given the key and its
uper K,? super V,? extends V> remappingFunction)      current mapped value if the value for the specified key is                                                          present and non-null.

boolean containsValue(Object value)               This method returns true if some value equal to the value                                                        exists within the map, else return false.

boolean containsKey(Object key)                                This method returns true if some key equal to the key                                                         exists within the map, else return false.

boolean equals(Object o)      It is used to compare the specified Object with the Map.

void forEach(BiConsumer<? super K,? super V> action)   It performs the given action for each entry in the map until                                                            all entries have been processed or the action throws an                                                            exception.

V get(Object key)         This method returns the object that contains the value associated with the key.

V getOrDefault(Object key, V defaultValue)               It returns the value to which the specified key is mapped,                                                          or defaultValue if the map contains no mapping for the key.

int hashCode()                                                It returns the hash code value for the Map
boolean isEmpty()                                       This method returns true if the map is empty;
                                                              returns false if it contains at least one key.


V replace(K key, V value)                                It replaces the specified value for a specified key.
boolean replace(K key, V oldValue, V newValue)      It replaces the old value with the new value for a specified key.

void replaceAll(BiFunction<? super K,? super V,?        It replaces each entry's value with the result of invoking    extends V> function)                                   the given function on that entry until all entries have                                                             been processed or the function throws an exception.

Collection values()                              It returns a collection view of the values contained in the map.

--------------------------------------------------------------------------------------------
some examples =>
    System.out.println(map.get(null));//null

*The getOrDefault(Object key, V defaultValue) method of Map interface, implemented by HashMap class
is used to get the value mapped with specified key. If no value is mapped with the provided key then the default value is returned.

public class AppTest {
public static void main(String[] args) {
      Map<Integer,String> map=new HashMap<>();
      Map<Integer,String> map2=new HashMap<>();
      
      
      map2.put(9,"A");
      map2.put(1,"b");
      map2.put(5,"x");
      map2.put(11,"t");
      

map.put(3,"A");
map.put(2, "c");
map.put(7,"u");
map.put(5, "v");
map.put(5,"a");
map.put(null,null);
map.put(null,null);
map.put(null, "y");
System.out.println(map);
map.putAll(map2);
System.out.println(map.size());
System.out.println(map.get(5));
System.out.println(map.get(null));
map.putIfAbsent(14, "jason");
System.out.println(map);
map.remove(3);

System.out.println(map);
System.out.println(map.keySet());
System.out.println(map.containsValue("x"));//case sensitive
System.out.println(map.containsKey(3));
System.out.println(map.isEmpty());
System.out.println(map.values());
System.out.println(map.getOrDefault(7,"faf"));//get value of 7 if 7 is not exist then set faf value

map.replace(14, "john");
System.out.println(map);

}
}


o/p->

{null=y, 2=c, 3=A, 5=a, 7=u}
8
x
y
{null=y, 1=b, 2=c, 3=A, 5=x, 7=u, 9=A, 11=t, 14=jason}
{null=y, 1=b, 2=c, 5=x, 7=u, 9=A, 11=t, 14=jason}
[null, 1, 2, 5, 7, 9, 11, 14]
true
false
false
[y, b, c, x, u, A, t, jason]
u
{null=y, 1=b, 2=c, 5=x, 7=u, 9=A, 11=t, 14=john}
--------------------------------------------------------
Set<Map.Entry<K,V>> entrySet()

Set<Entry<Integer, String>> entrySet = map.entrySet();
System.out.println(entrySet);

o/p=>[null=y, 1=b, 2=c, 5=x, 7=u, 9=A, 11=t, 14=john]

-----------------------------------------------------------------
Map.Entry Interface->

*Entry is the subinterface of Map. So we will be accessed it by Map.Entry name. It returns a collection-view of the map, 
whose elements are of this class. It provides methods to get key and value.

*A Map can't be traversed, so you need to convert it into Set using keySet() or entrySet() method.
*
K getKey()  It is used to obtain a key.
V getValue()      It is used to obtain value.
V setValue(V value)     It is used to replace the value corresponding to this entry with the specified value.

public static void main(String args[]){  
  Map<Integer,String> map=new HashMap<Integer,String>();  
  map.put(100,"Amit");  
  map.put(101,"Vijay");  
  map.put(102,"Rahul");  
  //Elements can traverse in any order  
  for(Map.Entry m:map.entrySet()){  
   System.out.println(m.getKey()+" "+m.getValue());  
  }  
 }


map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByValue())  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  


 map.entrySet()  
     //Returns a sequential Stream with this collection as its source  
     .stream()  
     //Sorted according to the provided Comparator  
     .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))  
     //Performs an action for each element of this stream  
     .forEach(System.out::println);  

*map contain remove method
----------------------------------------------------------------
difference between hashmap and table

1) HashMap is non synchronized. It is not-thread safe and can't    Hashtable is synchronized. It is thread-safe and
be shared between many threads without proper synchronization code.     can be shared with many threads.
      
2) HashMap allows one null key and multiple null values.       Hashtable doesn't allow any null key or value.
3) HashMap is a new class introduced in JDK 1.2.                  Hashtable is a legacy class.
4) HashMap is fast.                                                        Hashtable is slow.

5) We can make the HashMap as synchronized by calling this code         Hashtable is internally synchronized
Map m = Collections.synchronizedMap(hashMap);                           and can't be unsynchronized.
6) HashMap is traversed by Iterator.                              Hashtable is traversed by Enumerator and Iterator.
7) Iterator in HashMap is fail-fast.                           Enumerator in Hashtable is not fail-fast.
8) HashMap inherits AbstractMap class.             Hashtable inherits Dictionary class.

-----------------------------------------------------------
hashmap internal working=>

*HashMap is a part of the Java collection framework. It uses a technique called Hashing. It implements the map interface. 
It stores the data in the pair of Key and Value. HashMap contains an array of the nodes, 
and the node is represented as a class. It uses an array and LinkedList data structure internally for storing Key and Value.

*hashing is the process of converting an object into an integer value. The integer value helps in indexing and faster searches.

*Buckets: Array of the node is called buckets. Each node has a data structure like a LinkedList. More than one node can share 
the same bucket. It may be different in capacity.

*We use put() method to insert the Key and Value pair in the HashMap. The default size of HashMap is 16 (0 to 15).

HashMap<String, Integer> map = new HashMap<>();  
map.put("Aman", 19);  
map.put("Sunny", 29);  
map.put("Ritesh", 39);  

*Let's see at which index the Key, value pair will be saved into HashMap. When we call the put() method,
 then it calculates the hash code of the Key "Aman." Suppose the hash code of "Aman" is 2657860. To store the 
Key in memory, we have to calculate the index.

index=hashcode/size of hashmap now reminder is consider as a index number.

*Hash collision=>if two keys are stored at same index number or two keys index is same
In this case, equals() method check that both Keys are equal or not. If Keys are same, replace the value
 with the current value. Otherwise, connect this node object to the existing node object through the LinkedList.
 Hence both Keys will be stored at index 4.
hashcode can be same for multiple objects.

*get() method is used to get the value by its Key. It will not fetch the value if you don't know the Key. When get(K Key) method 
is called, it calculates the hash code of the Key.
It generates the hash code as 2657860. Now calculate the index value of 2657860 by using index formula. 
The index value will be 4, as we have calculated above. get() method search for the index value 4. 
It compares the first element Key with the given Key. If both keys are equal, 
then it returns the value else check for the next element in the node if it exists. In our scenario, 
it is found as the first element of the node and return the value 19.
-------------------------------------------------------------------------------------
concurrent hashmap->
public class ConcurrentHashMap<K,V>  
extends AbstractMap<K,V>  
implements ConcurrentMap<K,V>, Serializable

* The ConcurrentHashMap class is introduced in JDK 1.5 belongs to java.util.concurrent package, 
which implements ConcurrentMap as well as to Serializable interface also. ConcurrentHashMap is 
an enhancement of HashMap as we know that while dealing with Threads in our application HashMap is 
not a good choice because performance-wise HashMap is not up to the mark.

*ConcurrentHashMap is a thread-safe implementation of the Map interface in Java, 
which means multiple threads can access it simultaneously without any synchronization issues.
 It’s part of the java.util.concurrent package

* the ConcurrentHashMap provides various methods for atomic operations such as putIfAbsent(), replace(), and remove().

*In ConcurrentHashMap, the Object is divided into a number of segments according to the concurrency level.
*Inserting null objects is not possible in ConcurrentHashMap as a key or value.
*The default concurrency-level of ConcurrentHashMap is 16.
 public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
 
        // Adding elements to the map
        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);
 
        System.out.println("Map size: " + map.size());
 
        // Getting values from the map
        int valueA = map.get("A");
        System.out.println("Value of A: " + valueA);
 
        // Removing elements from the map
        map.remove("B");
        System.out.println("Map size: " + map.size());
    }

*The default concurrency-level of ConcurrentHashMap is 16.

--------------------------------------------------******-------------------------------------
TreeMap->  
       *Java TreeMap class is a red-black tree based implementation. It provides an efficient means of storing key-value pairs in sorted order.

*Java TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
*Java TreeMap contains only unique elements.
*Java TreeMap cannot have a null key but can have multiple null values.
*Java TreeMap is non synchronized.
*Java TreeMap maintains ascending order.

public static void main(String args[]){  
   TreeMap<Integer,String> map=new TreeMap<Integer,String>();    
      map.put(100,"Amit");    
      map.put(102,"Ravi");    
      map.put(101,"Vijay");    
      map.put(103,"Rahul");    
       
      for(Map.Entry m:map.entrySet()){    
       System.out.println(m.getKey()+" "+m.getValue());    
      }    
 }  


methods ->

K firstKey()                          It is used to return the first (lowest) key currently in this sorted map.

K lastKey()                          It is used to return the last (highest) key currently in the sorted map.

NavigableSet<K> descendingKeySet()  It returns a reverse order NavigableSet view of the keys contained in the map.
NavigableMap<K,V> descendingMap()   It returns the specified key-value pairs in descending order.

Map.Entry firstEntry()                   It returns the key-value pair having the least key.

K higherKey(K key)                              It is used to return true if this map contains a mapping for the specified key.
Set keySet()                            It returns the collection of keys exist in the map.
Map.Entry<K,V> lastEntry()    It returns the key-value pair having the greatest key, or null if there is no such key.
---------------------------------------------------------------------------
What is difference between HashMap and TreeMap?
HashMap     TreeMap
1) HashMap can contain one null key.      TreeMap cannot contain any null key.
2) HashMap maintains no order.      TreeMap maintains ascending order.
--------------------------------------------------------
eample->

TreeMap<String ,String> tree1=new TreeMap<>();
tree1.put("t","c");
tree1.put("a","v");
tree1.put("v","x");
System.out.println("------------------------");
System.out.println(tree1.firstKey());
System.out.println(tree1.firstEntry());
System.out.println(tree1.higherKey("t"));
System.out.println(tree1.higherEntry("t"));
System.out.println(tree1.descendingMap());
System.out.println(tree1.descendingKeySet());
System.out.println(tree1.tailMap("a"));

}}

o/p=>a
a=v
v
v=x
{v=x, t=c, a=v}
[v, t, a]
{a=v, t=c, v=x}

*if we create map like this
TreeMap<Student ,String> tree2=new TreeMap<>(); then Students implements Comparable<Student> otherwise we get this exception

Exception in thread "main" java.lang.ClassCastException: corejavaapp.Student cannot be cast to java.lang.Comparable
      at java.util.TreeMap.getEntry(TreeMap.java:349)

*TreeMap<String,Student> tree3=new TreeMap<>();  but in this scenario not get any exception
-------------------------------------------------------*******----------------------------------------------
fail safe and fail fast->

*Iterators in Java are part of the Java Collection framework. They are used to retrieve elements one by one. The Java Collection supports two types of iterators; Fail Fast and Fail Safe. These iterators are very useful in exception handling.

Fail fast=>
*The Fail fast iterator aborts the operation as soon it exposes failures and stops the entire operation.
* {  
            Map<String, String> empName = new HashMap<String, String>();  
            empName.put("Sam Hanks", "New york");  
            empName.put("Will Smith", "LA");  
            empName.put("Scarlett", "Chicago");  
            Iterator iterator = empName.keySet().iterator();  
            while (iterator.hasNext()) {  
                System.out.println(empName.get(iterator.next()));  
                // adding an element to Map  
                // exception will be thrown on next call  
                // of next() method.  
                empName.put("Istanbul", "Turkey");  
            }  
        }  


*The Fail Fast iterator throws a ConcurrentModificationException if a collection is modified while iterating over it.
*The Fail Fast iterator uses an original collection to traverse over the collection's elements.
*They are memory savers, don't require extra memory.
*The Fail Fast iterators returned by ArrayList, HashMap, Vector classes.

fale safe=>
* Comparatively, Fail Safe iterator doesn't abort the operation in case of a failure. Instead, it tries to avoid failures as much as possible.
*

public static void main(String args[])  
    {  
        CopyOnWriteArrayList<Integer> list  
            = new CopyOnWriteArrayList<Integer>(new Integer[] { 1, 7, 9, 11 });  
        Iterator itr = list.iterator();  
        while (itr.hasNext()) {  
            Integer i = (Integer)itr.next();  
            System.out.println(i);  
            if (i == 7)  
                list.add(15); // It will not be printed  
            //This means it has created a separate copy of the collection  
        }  
    }  


 public static void main(String[] args)  
    {  
        // Initializing a ConcurrentHashMap  
        ConcurrentHashMap<String, Integer> m  
            = new ConcurrentHashMap<String, Integer>();  
        m.put("ONE", 1); //Adding values  
        m.put("SEVEN", 7);  
        m.put("FIVE", 5);  
        m.put("EIGHT", 8);  
        // Getting an iterator using map  
        Iterator it = m.keySet().iterator();  
        while (it.hasNext()) {  
            String key = (String)it.next();  
            System.out.println(key + " : " + m.get(key));  
            // This will reflect in iterator.  
            // This means it has not created separate copy of objects  
            m.put("NINE", 9);  
        }  
    }  

*Concurrent Modification

The Concurrent modification in Java is to modify an object concurrently while another task is running over it. In simple terms, concurrent modification is the process of modifying objects while another thread is running over them. It will change the structure of the data collection, either by removing, adding, or updating the value of the elements in the collection.

Not all iterators support this behavior; implementation of some iterator may throw ConcurrentModificationException.

There are several other comparisons between them on the basis of different parameters. Let's discuss them:

      Fail Fast Iterator                                                            Fail Safe Iterator
It throws a ConcurrentModificationException in modifying the .
object during the iteration process                                  It does not throw Exception.

No clone object is created during the iteration process.       A copy or clone object is created during the iteration process.

It requires low memory during the process.               It requires more memory during the process.

It does not allow modification during iteration.      It allows modification during the iteration process.
      It is fast.                                      It is slightly slower than Fail Fast.
sExamples   HashMap, ArrayList, Vector, HashSet, etc  CopyOnWriteArrayList, ConcurrentHashMap, etc.

--------------------------------------------------******-------------------------------------------------
Comparable and Comparator interface->Comparable and Comparator both are interfaces and can be used to
                                sort collection elements.
                                         
Comparable->*Comparable provides a single sorting sequence. In other words, we can sort the collection on the basis of a single element such as id, name, and price.

         *A comparable object is capable of comparing itself with another object. The class itself must implements the java.lang.Comparable interface to compare its instances.

*Comparable is meant for objects with natural ordering which means the object itself must know how it is to be ordered. For example Roll Numbers of students.

*Logically, Comparable interface compares “this” reference with the object specified

*if sorting of objects needs to be based on natural order then use Comparable

*If any class implements Comparable interface in Java then collection of that object either List or Array can be sorted automatically by using Collections.sort() or Arrays.sort() method and objects will be sorted based on there natural order defined by CompareTo method.

*comparable we can use only one comparison.

*it has compareTo() method and its internal working like---
if current object and specified obj both are equal then return 0 .If currrent is greater than specified then swapping will happen and return 1 and if current id less then specified object then swapping will not happen and return -1.
                 
String st1="hello";
String st2="apple";
System.out.println(st1.compareTo(st2));//swapping will happen and +1

ex.      class Student implements Comparable<Student>{  
int rollno;  
String name;  
int age;  
Student(int rollno,String name,int age){  
this.rollno=rollno;  
this.name=name;  
this.age=age;  
}  
public int compareTo(Student st){  
if(age==st.age)  
return 0;  
else if(age>st.age)  
return 1;  
else  
return -1;  
}  
}  
//Creating a test class to sort the elements  
public class TestSort3{  
public static void main(String args[]){  
ArrayList<Student> al=new ArrayList<Student>();  
al.add(new Student(101,"Vijay",23));  
al.add(new Student(106,"Ajay",27));  
al.add(new Student(105,"Jai",21));  
 
Collections.sort(al);  
for(Student st:al){  
System.out.println(st.rollno+" "+st.name+" "+st.age);  
}  
}  
}  


*Imp->*in comparable Comparable affects the original class, i.e., the actual class is modified.
It means--
*
 Public class Student implements Comparable<Student>{
@Override
      public int compareTo(Student o) {
            
            if(age==o.getAge())                       //here we not get any compile time error
            // TODO Auto-generated method stub
            return 0;
      }

}   is possible only


*but
public class AgeComparator implements Comparable<Student>{
@Override
      public int compareTo(Student o) {
            
            if(age==o.getAge())                       //here we get compile time error
            // TODO Auto-generated method stub
            return 0;
      }


so that's the reason we cannot sort elements based on multiple elements

Comparator->
          *The Comparator provides multiple sorting sequences. In other words, we can sort the collection on the basis of multiple elements such as id, name, and price etc.
*Comparator provides compare() method to sort elements.
*We can sort the list elements of Comparator type by Collections.sort(List, Comparator) method.

ex.  

 class Student{  
int rollno;  
String name;  
int age;  
Student(int rollno,String name,int age){  
this.rollno=rollno;  
this.name=name;  
this.age=age;  
}  
}  


class AgeComparator implements Comparator<Student>{  
public int compare(Student s1,Student s2){  
if(s1.age==s2.age)  
return 0;  
else if(s1.age>s2.age)  
return 1;  
else  
return -1;  
}  
}  
NameComparator.java
This class provides comparison logic based on the name. In such case, we are using the compareTo() method of String class, which internally provides the comparison logic.

import java.util.*;  
class NameComparator implements Comparator<Student>{  
public int compare(Student s1,Student s2){  
return s1.name.compareTo(s2.name);  
}  
}  
TestComparator.java
In this class, we are printing the values of the object by sorting on the basis of name and age.

//Java Program to demonstrate the use of Java Comparator  
import java.util.*;  
import java.io.*;  
class TestComparator{  
public static void main(String args[]){  
//Creating a list of students  
ArrayList<Student> al=new ArrayList<Student>();  
al.add(new Student(101,"Vijay",23));  
al.add(new Student(106,"Ajay",27));  
al.add(new Student(105,"Jai",21));  
 
System.out.println("Sorting by Name");  
//Using NameComparator to sort the elements  
Collections.sort(al,new NameComparator());  
//Traversing the elements of list  
for(Student st: al){  
System.out.println(st.rollno+" "+st.name+" "+st.age);  
}  
 
System.out.println("sorting by Age");  
//Using AgeComparator to sort the elements  
Collections.sort(al,new AgeComparator());  
//Travering the list again  
for(Student st: al){  
System.out.println(st.rollno+" "+st.name+" "+st.age);  
}  
 
}  
}  


difference b/w comparable and comparator->

Comparable  Comparator
1) Comparable provides a single sorting sequence.    The Comparator provides multiple sorting sequences.
In other words, we can sort the collection on        In other words, we can sort the collection on the
 the basis of a single element such as id,            of multiple elements such as id,and price
 name, and price.

2) Comparable affects the original class, i.e.,         Comparator doesn't affect the original class,      the actual class is modified.                         i.e., the actual class is not modified.

3) Comparable provides compareTo() method to       Comparator provides compare() method to sort elements.
sort elements.
      
4) Comparable is present in java.lang package.       A Comparator is present in the java.util package.

5) We can sort the list elements of Comparable .      We can sort the list elements of Comparator type type by Collections.sort(List) method                   by Collections.sort(List, Comparator) method.

======================================================================================================
Collection based Interview Questions=>

Q..1) What are the main differences between array and collection?

Arrays are always of fixed size, i.e., a user can not increase or decrease the length of the array according to their requirement or at runtime, but In Collection, size can be changed dynamically as per need.
Arrays can only store homogeneous or similar type objects, but in Collection, heterogeneous objects can be stored.
Arrays cannot provide the ?ready-made? methods for user requirements as sorting, searching, etc. but Collection includes readymade methods to use

---------------------------------------------------------------
Q  2)   What is the difference between ArrayList and Vector?

1)    ArrayList is not synchronized.                          Vector is synchronized.
2)    ArrayList is not a legacy class.                Vector is a legacy class.
3)    ArrayList increases its size by            Vector increases its size by doubling the array size.
50% of the array size.    
4)    ArrayList is not ?thread-safe? as it is not synchronized.   Vector list is ?thread-safe? as it?s every method is synchronized.                                        it?s every method is synchronized.
--------------------------------------------------------------

Q  3)  5) What is the difference between ArrayList and LinkedList?

ArrayList takes less memory overhead as it stores        LinkedList takes more memory overhead, as             only object                             it stores the object as well as the address of that object.

------------------------------------------------------------------

Q 4)  What is the difference between Iterator and ListIterator?

No.   Iterator                                                       ListIterator
1)    The Iterator traverses the elements              ListIterator traverses the elements in backward and         in the forward direction only.                  forward directions both.

The Iterator can be used in List, Set, and Queue.     ListIterator can be used in List only.

3The Iterator can only perform remove operation         ListIterator can perform ?add,? ?remove,?
while traversing the collection.                  and ?set? operation while traversing the collection.
----------------------------------------------------------------------

Q 5) What is the difference between Iterator and Enumeration?

The Iterator is fail-fast.                                        Enumeration is not fail-fast.

3)    The Iterator is slower than Enumeration.           Enumeration is faster than Iterator.

4)    The Iterator can perform remove operation The Enumeration can perform only traverse          while traversing the collection.                         operation on the collection.
------------------------------------------------------------------------
Q 6)  What is the difference between List and Set?

The List can contain duplicate elements whereas Set includes unique items.
The List is an ordered collection which maintains the insertion order whereas Set is an unordered collection which does not preserve the insertion order.
The List interface contains a single legacy class which is Vector class whereas Set interface does not have any legacy class.
The List interface can allow n number of null values whereas Set interface only allows a single null value.

------------------------------------------------------------------------

Q7)  What is the difference between HashSet and TreeSet?

HashSet maintains no order whereas TreeSet maintains ascending order.
HashSet impended by hash table whereas TreeSet implemented by a Tree structure.
HashSet performs faster than TreeSet.
HashSet is backed by HashMap whereas TreeSet is backed by TreeMap.
-----------------------------------------------------------------------
Q 8) What is the difference between Set and Map?

Set contains values only whereas Map contains key and values both.
Set contains unique values whereas Map can contain unique Keys with duplicate values.
Set holds a single number of null value whereas Map can include a single null key with n number of null values.
---------------------------------------------------------------------------------
Q 9) What is the difference between HashSet and HashMap?

HashSet contains only values whereas HashMap includes the entry (key, value). HashSet can be iterated, but HashMap needs to convert into Set to be iterated.
HashSet implements Set interface whereas HashMap implements the Map interface
HashSet cannot have any duplicate value whereas HashMap can contain duplicate values with unique keys.
HashSet contains the only single number of null value whereas HashMap can hold a single null key with n number of null values.
---------------------------------------------------------------------------

Q 10) What is the difference between HashMap and TreeMap?

HashMap maintains no order, but TreeMap maintains ascending order.
HashMap is implemented by hash table whereas TreeMap is implemented by a Tree structure.
HashMap can be sorted by Key or value whereas TreeMap can be sorted by Key.
HashMap may contain a null key with multiple null values whereas TreeMap cannot hold a null key but can have multiple null values.

--------------------------------------------------------------------------------------

Q 11) What is the difference between HashMap and Hashtable?

HashMap     Hashtable
1)    HashMap is not synchronized.  Hashtable is synchronized.
2)    HashMap can contain one null key and multiple null values.  Hashtable cannot contain any null key or null value.
3)    HashMap is not ?thread-safe,? so it is useful for non-threaded applications.  Hashtable is thread-safe, and it can be shared between various threads.
4)    4) HashMap inherits the AbstractMap class Hashtable inherits the Dictionary class.
------------------------------------------------------------------------------------------
Q 12) What is the difference between Collection and Collections?


The Collection is an interface whereas Collections is a class.
The Collection interface provides the standard functionality of data structure to List, Set, and Queue. However, Collections class is to sort and synchronize the collection elements.
The Collection interface provides the methods that can be used for data structure whereas Collections class provides the static methods which can be used for various operation on a collection.
---------------------------------------------------------------------------------------

Q 13)  What is the advantage of Properties file?
If you change the value in the properties file, you don't need to recompile the java class. So, it makes the application easy to manage. It is used to store information which is to be changed frequently. Consider the following example.

import java.util.*;  
import java.io.*;  
public class Test {  
public static void main(String[] args)throws Exception{  
    FileReader reader=new FileReader("db.properties");  
     
    Properties p=new Properties();  
    p.load(reader);  
     
    System.out.println(p.getProperty("user"));  
    System.out.println(p.getProperty("password"));  
}  
}  
---------------------------------------------------------------------------------------------
Q 14) What is the advantage of the generic collection?


If we use the generic class, we don't need typecasting.
It is type-safe and checked at compile time.
Generic confirms the stability of the code by making it bug detectable at compile time.
----------------------------------------------------------------------------
Q 15)  What is the difference between Array and ArrayList?
The main differences between the Array and ArrayList are given below.

SN    Array                                                   ArrayList
1The Array is of fixed size,                          ArrayList is not of the fixed size we
means we cannot resize the array as per need.           can change the size dynamically.

2Arrays are of the static type.                              ArrayList is of dynamic size.

3Arrays can store primitive data types as well as objects.  ArrayList cannot store the primitive data                                                           types it can only store the objects.
--------------------------------------------------------------------------------
Q 16)   How to convert ArrayList to Array and Array to ArrayList?
*We can convert an Array to ArrayList by using the asList() method of Arrays class.
Arrays.asList(item)  

*We can convert an ArrayList to Array using toArray() method of the ArrayList class.
List_object.toArray(new String[List_object.size()])  
---------------------------------------------------------------------------------
Q 17)  How to make Java ArrayList Read-Only?

We can obtain java ArrayList Read-only by calling the Collections.unmodifiableCollection() method. When we define an ArrayList as Read-only then we cannot perform any modification in the collection through  add(), remove() or set() method.
psvm(){
 List<String>fruitList = new ArrayList<String>();  
 
        fruitList.add("Mango");  
        fruitList.add("Banana");  
        fruitList.add("Apple");  
        fruitList.add("Strawberry");  
        fruitList.add("Pineapple");  
         
    List<String>unmodifiableList= Collections.unmodifiableList(fruitList);  
    unmodifiableList.add("INDIA");  
    System.out.println(fruitList);  
}

o/p=>UnsupportedOperationException
-----------------------------------------------------------------------------------

Q 18) 1How many times null elements will be displayed in the following code?

import java.util.ArrayList;
public class ArrayListTest {
public static void main(String[] args)
{
   ArrayList<String> list = new ArrayList<String>();
     list.add(null);
     list.add(1, null);
     list.add(1, null);
     list.add(1, null);
     System.out.println(list);
  }
}
Answer: null will be printed 4 times because if any element is already present at the specified position, ArrayList shifts that element to the right side. Therefore, Output: [null, null, null, null].
-----------------------------------------------------------------------------
Q 19)  what is o/p
public static void main(String[] args)
{
   ArrayList<String> list = new ArrayList<String>();
    list.add(null);
    list.add(0, "A");
    list.add(3, "B");
    list.add(1, "C");
    System.out.println(list);
   }

o/p runntime exception
ndexOutOfBoundsException: Index: 3, Size: 2
      at java.util.ArrayList.rangeCheckForAdd(ArrayList.java:667)

-------------------------------------------------------------------------------
Q 20)
ArrayList<String> list = new ArrayList<String>();
list.add(null);
list.add(null);
list.add(0, "A");
list.add(2, "B");
list.add(1, "C");
System.out.println(list);

o/p=>  Output: [A, C, null, B].
-----------------------------------------------------------------
Q21) ArrayList<String> list = new ArrayList<String>();
    list.add(null);
    list.add(0, "A");
    list.add(null);
    list.add(2, "B");
    list.add("20");
    list.add(1, "C");
   System.out.println(list);

o/p=>[A, C, null, B, null, 20]
cbecause adding is started from starting or upper side
----------------------------------------------------------------
Q 22) Why adding or inserting elements to ArrayList can be slow?

Answer: When the size of ArrayList is unknown then adding elements to ArrayList is slow. When the size of ArrayList grows, a lot of shifting takes place in the memory while adding elements. Due to which the performance of ArrayList becomes slow.
-----------------------------------------------------
Q 23)2. How to reverse ArrayList in Java? (Answer)
 Collections.reverse();

ArrayList<Integer> list=new ArrayList<>();
list.add(12);
list.add(17);
list.add(23);
list.add(5);

for(int i=list.size()-1;i>=0;i--) {
System.out.println(list.get(i));}
-------------------------------------------------------------
Q 24)  How to sort ArrayList in Java?
Collections.sort(list);
list .stream().sorted().forEach(System.out::println);
------------------------------------------------------------
Q 25) How to sort ArrayList in descending order in Java?
Collections.reverseComparator()

Comparator<Integer> c=(c1,c2)->c2.compareTo(c1);
list .stream().sorted(c).forEach(System.out::println);
------------------------------------------------------------
Q 26) How to print duplicate values in Arraylist in Java?

psvm(){
ArrayList<Integer> list=new ArrayList<>();
ArrayList<Integer> newList=new ArrayList<>();
list.add(12);
list.add(17);
list.add(17);
list.add(5);
list.add(12);

Set<Integer> s=new HashSet<>();
for(int a:list) {
      if(s.add(a)==false) {
            newList.add(a);
      }
}
System.out.println(newList);
}
------------------------------------------------------------
Q 27) How to compare two Arraylists of different size in Java?

ArrayList<String> firstList=new ArrayList<String>();  
//adds elements to the arraylist  
firstList.add("Apple");  
firstList.add("Pears");  
firstList.add("Guava");  
firstList.add("Mango");  
System.out.println(firstList);  
//second array list      
List<String> secondList=new ArrayList<String>();  
//adds elements to the arraylist  
secondList.add("Apple");  
secondList.add("Pears");  
secondList.add("Guava");  
secondList.add("Mango");  
System.out.println(secondList);  
//comparing both lists  
boolean boolval = firstList.equals(secondList); //returns true because lists are equal  
System.out.println(boolval);
-------------------------------------------------------------
Q 28) How to get input from user in Arraylist in Java?

 List l=new ArrayList();
                System.out.println("Enter the input");
                Scanner input=new Scanner(System.in);

                 String a =input.nextLine();
                 l.add(a);
----------------------------------------------------------------
Q 29) How to store Arraylist data into Excel in Java?

psvm(){
HSSFWorkbook workbook=new HSSFWorkbook();
        File f=new File("D:/Test/test.xls");
        GeericExcelGenerator gl=new GeericExcelGenerator("Test",workbook);
        FileOutputStream outputStream=new FileOutputStream(f);
        gl.generate(outputStream,arrlist);
}



public void generate(OutputStream outputStream,ArrayList arrlist) throws SQLException, IOException, NestableException
    {
        try
        {
            int currentRow = 0;
            for (int counter = 0; counter < arrlist.size(); counter++) {    

                HSSFRow row = sheet.createRow(currentRow);
                System.out.println("Description is"+arrlist.get(counter));

                String c=(String) arrlist.get(counter);
                int i=0;
                HSSFCell cell = HSSFCellUtil.createCell(row, i, null);
                cell.setCellValue(c);

                 i++;
                workbook.write(outputStream);
                currentRow++;
                currentRow++;
            }
        }catch(IOException  e)
        {}
        finally {
            outputStream.close();
        }
    }
----------------------------------------------------------------
Q 30)How to compare two Arraylist of objects in Java and find difference?

secondList.removeAll(firstList);  
//prints the element of second list which does not match with the element of the first list  
System.out.println(secondList);  


ArrayList<Integer> list=new ArrayList<>();
ArrayList<Integer> list2=new ArrayList<>();


list2.add(112);
list2.add(17);
list2.add(33);
list2.add(5);
list2.add(12);

list.add(12);
list.add(17);
list.add(17);
list.add(5);
list.add(12);

list2.removeAll(list);
System.out.println(list2);
----------------------------------------------------------------------
Q 31)Can Arraylist be static in Java?
static ArrayList at=new ArrayList();
------------------------------------------------------------------------
map and set based
Q 32)What is one-to-one mapping in Java?

Answer: Each key maps to only one value. This type of mapping is called one-to-one mapping in java.
-------------------------------------------------------------------

Q 33) linkedhashmap

 The LinkedHashMap provides a way to order and trace the elements. Comparatively, the HashMap does not support the 
ordering of the elements.
------------------------------------------------------------------------
Q 34) Can we use any user-defined class as Map key?

Answer: Yes, we can use any user-defined class as Map key.
-------------------------------------------------------------------------

Q 35)  
public static void main(String[] args)
{
 Map<Integer, String> map = new HashMap<>();
 map.put(101, "Red");
 map.put(103, "Green");
 map.put(102, "Yellow");
 map.remove(104);
 map.remove(106,"Pink");
 System.out.println(map);
 }
Output:
      {101=Red, 102=Yellow, 103=Green}

--------------------------------------------------------------------------
Q 36) sort map by values

Map<Integer, String> map = new HashMap<>();
map.put(101, "Red");
map.put(103, "Green");
map.put(102, "Yellow");
map.remove(104);
map.remove(106,"Pink");

TreeSet<String> tree=new TreeSet<>();
for(Map.Entry<Integer, String> m:map.entrySet()) {
      tree.add(m.getValue());
}
System.out.println(tree);
}
--------------------------------------------------------------------------

Q 37) sort map by keys

treeMap

____________________________________________________________________________________________________________
equals and hashcode code for overriding->

*The equals() and hashcode() are the two important methods provided by the Object class for comparing objects. Since the Object class is the parent class for all Java objects

equals()=>The java equals() is a method of lang.Object class, and it is used to compare two objects.
To compare two objects that whether they are the same, it compares the values of both the object's attributes.
By default, two objects will be the same only if stored in the same memory location.

hashcode->A hashcode is an integer value associated with every object in Java, facilitating the hashing in hash tables.
To get this hashcode value for an object, we can use the hashcode() method in Java. It is the means hashcode()
method that returns the integer hashcode value of the given object.

* hashcode() method that returns the integer hashcode value of the given object.

*The hashcode() method returns the same hash value when called on two objects, which are equal according to the equals() method. And if the objects are unequal, it usually returns different hash values.

*Contract for hashcode() method in Java
If two objects are the same as per the equals(Object) method, then if we call the hashCode() method on each of 
the two objects, it must provide the same integer result.

@Override
    public int hashCode()
    {
           
       
        return this.id;
    }


Note: As per the Java documentation, both the methods should be overridden to get the complete equality mechanism; using equals() alone is not sufficient. It means, if we override the equals(), we must override the hashcode() method

*It is perfectly legal for two objects to have the same hashcode. If two objects are equal (using the equals() method) then they have the same hashcode. If two objects are not equal then they cannot have the same hashcode.

*To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

Since compile-time errors are better than runtime errors, Java renders compile-time error if you inherit 2 classes. So whether you have same method or different, there will be compile time error.
                                   
class A{  
void msg(){System.out.println("Hello");}  
}  
class B{  
void msg(){System.out.println("Welcome");}  
}  
class C extends A,B{//suppose if it were  //compile time error
   
 public static void main(String args[]){  
   C obj=new C();  
   obj.msg();//Now which msg() method would be invoked?  
}  
}

  
____________________________________________________________________________________________________________________________________________________________________
STRING=>

 *In Java, string is basically an object that represents sequence of char values

 *Java String class provides a lot of methods to perform operations on strings such as compare(), 
        concat(), equals(), split(),length(), replace(), compareTo(), intern(), substring() etc.

 *The java.lang.String class implements Serializable, Comparable and CharSequence interfaces.

 *The CharSequence interface is used to represent the sequence of characters.

 *The Java String is immutable which means it cannot be changed. Whenever we change any string, a new instance is created. 
For mutable strings, you can use StringBuffer and StringBuilder classes.
--------------------------------------------------------------------------------------
*There are two ways to create String object:

1) String Literal
Java String literal is created by using double quotes. For Example:

String s="welcome"; 

*Each time you create a string literal, the JVM checks the "string constant pool" first. 
If the string already exists in the pool, a reference to the pooled instance is returned.
 If the string doesn't exist in the pool, a new string instance is created and placed in the pool. For example:

String s1="Welcome";  
String s2="Welcome";//It doesn't create a new instance 

*In the above example, only one object will be created. Firstly, JVM will not find any string object with 
the value "Welcome" in string constant pool that is why it will create a new object. After that it will find t
he string with the value "Welcome" in the pool, it will not create a new object but will return the reference to 
the same instance.

*String objects are stored in a special memory area known as the "string constant pool".
-------------------
2) By new keyword

String s=new String("Welcome")  
*In such case, JVM will create a new string object in normal (non-pool) heap memory
---------------------------------------------------------------------------------------------------------------------------
Mehods=>

Method	Description
1	char charAt(int index)	                                           It returns char value for the particular index
2	int length()	                                                   It returns string length
3	static String format(String format, Object... args)	           It returns a formatted string.
4	static String format(Locale l, String format, Object... args)	    It returns formatted string with given locale.
5	String substring(int beginIndex)	                           It returns substring for given begin index.
6	String substring(int beginIndex, int endIndex)	                  It returns substring for given begin index and end index.
7	boolean contains(CharSequence s)	                           It returns true or false after matching the sequence of char value.
	
8         static String join(CharSequence delimiter, CharSequence... elements)	                   It returns a joined string.
9	static String join(CharSequence delimiter, Iterable<? extends CharSequence> elements)	   It returns a joined string.
10	boolean equals(Object another)	                                                          It checks the equality of string with the given object.
11	boolean isEmpty()	                                                                  It checks if string is empty.
12	String concat(String str)	                                                            It concatenates the specified string.
13	String replace(char old, char new)	                                                It replaces all occurrences of the specified char value.
14	String replace(CharSequence old, CharSequence new)	                               It replaces all occurrences of the specified CharSequence.
15	static String equalsIgnoreCase(String another)                                    	It compares another string. It doesn't check case.
16	String[] split(String regex)	                                                       It returns a split string matching regex.
17	String[] split(String regex, int limit)	                                              It returns a split string matching regex and limit.
18	String intern()	                                                                            It returns an interned string.
19	int indexOf(int ch)	                                                                It returns the specified char value index.
20	int indexOf(int ch, int fromIndex)	                                          It returns the specified char value index starting with given index.
21	int indexOf(String substring)	                                                        It returns the specified substring index.
22	int indexOf(String substring, int fromIndex)	                                  It returns the specified substring index starting with given index.
23	String toLowerCase()	                                                             It returns a string in lowercase.
24	String toLowerCase(Locale l)	                                                     It returns a string in lowercase using specified locale.
25	String toUpperCase()	                                                             It returns a string in uppercase.
26	String toUpperCase(Locale l)	                                           It returns a string in uppercase using specified locale.
27	String trim()	                                                        It removes beginning and ending spaces of this string.
28	static String valueOf(int value)	                            It converts given type into string. It is an overloaded method.
-------------------------------------------------------------------------------------------------------------------
why string is immutable=>

*The String is immutable in Java because of the security, synchronization and concurrency, caching, 
and class loading. The reason of making string final is to destroy the immutability.

*In object-oriented programming, the immutable string or objects that cannot be modified once it is created. 
But we can only change the reference to the object. 
We restrict to change the object itself. The String is immutable in Java

These are some more reasons of making String immutable:

The String pool cannot be possible if String is not immutable in Java. A lot of heap space is saved by JRE.
 The same string variable can be referred to by more than one string variable in the pool.
 String interning can also not be possible if the String would not be immutable.
If we don't make the String immutable, it will pose a serious security threat to the application.
 For example, database usernames, passwords are passed as strings to receive database connections.
 The socket programming host and port descriptions are also passed as strings. The String is immutable, 
so its value cannot be changed. If the String doesn't remain immutable, any hacker can cause a security
 issue in the application by changing the reference value.
The String is safe for multithreading because of its immutableness. Different threads can access a 
single "String instance". It removes the synchronization for thread safety because we make strings thread-safe implicitly.
Immutability gives the security of loading the correct class by Classloader. 
For example, suppose we have an instance where we try to load java.sql.Connection class but 
the changes in the referenced value to the myhacked.Connection class does unwanted things to our database.


WHy string is immutable=>


These are some more reasons of making String immutable:

*The String pool cannot be possible if String is not immutable in Java. A lot of heap space is saved by JRE.
 The same string variable can be referred to by more than one string variable in the pool. String interning 
can also not be possible if the String would not be immutable.

*If we don't make the String immutable, it will pose a serious security threat to the application. For example, database usernames, passwords are passed as strings to receive database connections. The socket programming host and port descriptions are also passed as strings. The String is immutable, so its value cannot be changed. If the String doesn't remain immutable, any hacker can cause a security issue in the application by changing the reference value.

*The String is safe for multithreading because of its immutableness. Different threads can access a single "String instance".
 It removes the synchronization for thread safety because we make strings thread-safe implicitly.


*Immutability gives the security of loading the correct class by Classloader. For example, suppose we have an instance
 where we try to load java.sql.Connection class but the changes in the referenced value to the myhacked.Connection 
class does unwanted things to our database.
-------------------------------------------------------------------------------------

String s="j";
            String concat = s.concat("h");
            System.out.println(concat);

*string does not support append method but it will support concat method
String s="hello";
s.concat("hi);
sop(s)//hello
String s1=s.concat("hi);
sop(s1)//hellohi
--------------------------------------------------------------------------------------
String[]st=s.split("h");
            for(int i=0;i<st.length;i++) {
                  System.out.println(st[i]);
            }
---------------------------------------------------------------------------------------
intern() method=>*The Java String class intern() method returns the interned string
*It can be used to return string from memory if it is created by a new keyword. It creates an exact copy of the heap string object in the String Constant Pool.

When a string is created in Java, it occupies memory in the heap. Also, we know that the String class is immutable. Therefore, whenever we create a string using the new keyword, new memory is allocated in the heap for corresponding string, which is irrespective of the content of the array. Consider the following code snippet.

String str = new String("Welcome to JavaTpoint.");  
String str1 = new String("Welcome to JavaTpoint");  
System.out.println(str1 == str); // prints false

 
  need of intern() method->
public class InternExample{  
public static void main(String args[]){  
String s1=new String("hello");  
String s2="hello";  
String s3=s1.intern();//returns string from pool, now it will be same as s2  
System.out.println(s1==s2);//false because reference variables are pointing to different instance  
System.out.println(s2==s3);//true because reference variables are pointing to same instance  
}}
========================================================================================
interview questions=>

) How many objects will be created in the following code?
String s1="javatpoint";
String s2="javatpoint";
Answer: Only one.
-------------------------------------------------------
2) What is the difference between equals() method and == operator?
The equals() method matches content of the strings whereas == operator matches object or reference of the strings.  

3) Is String class final?
Answer: Yes.

----------------------------------------------------
4) how to reverse string in java

      String s="abcdefghijk";
            
            for(int i=s.length()-1;i>=0;i--) {
                  
                  System.out.println(s.charAt(i));
            }
            
-------------------------------------------------------

5) how to check palindrom string injava

public static void main(String[] args) {
                  checkPalindrom();
      }

      private static void checkPalindrom() {
            // TODO Auto-generated method stub
            String s="ababa";
            String rev="";
            boolean ans=false;
            for(int i=s.length()-1;i>=0;i--) {
                  rev=rev+s.charAt(i);
                  
                  
            }
            if(s.equals(rev)) {
                  System.out.println("string is palindrom");
            }
            else {
                  System.out.println("string is not palindrom");
            }
            
      
      }
--------------------------------------------------------


6) write a java program to reverse each word in string (but sequence of words in accending oredr)

String s2="hi hello how are you";
            String[] split = s2.trim().split(" ");
for(String st:split) {
                  for(int a=st.length()-1;a>=0;a--) {
                        System.out.print(st.charAt(a));
                        //System.out.println(",");
                  }
                  System.out.print("  ,");
            }
--------------------------------------------------------------

6) write a java program to print reverse a string by word like printvlast word at first

String s2="hi hello how are you";
            String[] split = s2.trim().split(" ");
            for(String sr:split) {
            c++;  
            }
            System.out.println(c);
            System.out.println(split);
            for(int i=split.length-1;i>=0;i--) {
                  System.out.print(split[i]+" ");
            }


-----------------------------------------------------------------

7)  difference b/w string,string buffer and builder

String is immutable whereas StringBuffer and StringBuilder are mutable classes.
StringBuffer is thread-safe and synchronized whereas StringBuilder is not. That’s why StringBuilder is faster than StringBuffer.
String concatenation operator (+) internally uses StringBuffer or StringBuilder class.
For String manipulations in a non-multi threaded environment, we should use StringBuilder else use StringBuffer class.
*append method is part of string buffer and builder
*StringBuffer sb=new StringBuffer("hello hi");
            sb.append("joy");
            System.out.println(sb);
-------------------------------------------------------------
8) how to convert string to int

String c2="firstpractice";
            
            try {
                  int parseInt = Integer.parseInt(c2);
            System.out.println(parseInt);
            }catch(Exception e) {
                  e.printStackTrace();
                  System.out.println("numberformat exception");
            }
            
------------------------------------------------------------

9) convert int to string




int n=90;
            String c1=String.valueOf(n);
            System.out.println(c1+""+c1.length());
----------------------------------------------------------
10) how to optimize java string creation

create object by literal

11) find duplicate chars in string

private static void findDuplicate() {
            // TODO Auto-generated method stub
            String dup="stuysyiouio";
            HashSet<Character> set=new HashSet<>();
            for(int i=0;i<dup.length();i++) {
            set.add(dup.charAt(i)); 
            }
            System.out.println("remove duplicat char");
            for(char c:set) {
                  System.out.print(c);
            }
            System.out.println();
      }


--------------------------------------------------------------
q) find duplicate char in string and return duplicate charcters


psvm(){
System.out.println("enter string");
	String dup=sc.next();
	List<Character> dupChar = findDuplicaateChar(dup);
	 for(char d:dupChar) {
		 System.out.print(d+",");
	 }
	 
	}
	private static List<Character> findDuplicaateChar(String s) {
		
		char[] charArray = s.toCharArray();
		//char[] dupArray = new char[charArray.length];
		List<Character> list=new ArrayList<>();
		Map<Character,Integer> map=new HashMap<Character,Integer>();
		for(Character c:charArray) {
		if(map.containsKey(c)) {
			map.put(c, map.get(c)+1);
		}
		else {
			map.put(c, 1);
		}
			
		}
		Set<Character> keySet = map.keySet();
		for(char c1:keySet) {
			if(map.get(c1)>1) {
				System.out.println(c1+"is present"+map.get(c1)+"times");
				//charArray=c1;
				list.add(c1);
			}
		}
		
+		return list;
		// TODO Auto-generated method stub
		
	}
---------------------------------------------------

12) prove that string are immutable

String s1 = "JAVA";
String s2 = "JAVA";

*We have seen in the previous article that string objects created using string literal are stored in the String Constant Pool 
and any two objects in the pool can’t have same content. Here s1 and s2 are created using same literal.
 Therefore, they will be pointing to same object in the pool. Then s1 == s2 should return true.

Now, I want to make little modification to this object through ‘s1’ reference. I want to append “J2EE” at end of this string through ‘s1’. That can be done like below,
s1 =s1 + "J2EE";

System.out.println(s1 == s2);       //Output : false
That means now both s1 and s2 are pointing to two different objects in the pool. Before modifications they are pointing
 to same object. Once we tried to change the content of the object using ‘s1’, a new object is created in the pool with 
“JAVAJ2EE” as it’s content and it’s reference is assigned to s1. If the strings are mutable, both s1 and s2 should point
 to same object even after modification. That never happened here. That proves the string objects are immutable in java.

-------------------------------------------------------

13) java program to count no. of words in string

private static void reverseWord() {

            int c=0;
            // TODO Auto-generated method stub
            String s2="hi hello how are you";
            String[] split = s2.trim().split(" ");
            for(String sr:split) {
            c++;  
            }
            System.out.println(c);
-------------------------------------------------------

14) remove particulat char from string



      first way=>

      String a1="abcdftyuio";
            System.out.println(charRemoveAt(a1,5));
      }

      private static String charRemoveAt(String a1, int i) {
            // TODO Auto-generated method stub
            
            
            return a1.substring(0, i)+a1.substring(i+1);
      }

second way=>
                  String a1="abcdftyuio";
            System.out.println(a1.replace("a", ""));
System.out.println(a1.replace("a", "").length());




---------------------------------------------------

15) contains method ex.=>

String st1="sdftsdftyuio"     ;
            System.out.println(st1.contains("sd"));//true

join methos ex=>

System.out.println(st1.contains("sd"));
            String n=null;
            String join = String .join("join","voin","soin",n);//joinvoinsoinnull

==============================================================================================================================
Exception =>
In Java, an exception is an event and Exception is an abnormal condition. that disrupts the normal flow of the program. 
It is an object which is thrown at runtime.

exception handling=>Exception Handling is a mechanism to handle runtime errors such as
 ClassNotFoundException, IOException, SQLException, RemoteException, etc.

Advantage of Exception Handling=>
The core advantage of exception handling is to maintain the normal flow of the application. An exception normally 
disrupts the normal flow of the application; that is why we need to handle exceptions.

1) Checked Exception
The classes that directly inherit the Throwable class except RuntimeException and 
Error are known as checked exceptions. For example, IOException, SQLException, ClassCasttException etc. Checked exceptions are checked
 at compile-time.

2) Unchecked Exception

The classes that inherit the RuntimeException are known as unchecked exceptions. For example, ArithmeticException,
 NullPointerException, ArrayIndexOutOfBoundsException, etc. Unchecked exceptions are not checked 
at compile-time, but they are checked at runtime.

int a=50/0;//ArithmeticException  
String s="abc";  
int i=Integer.parseInt(s);//NumberFormatException  

String s=null;  
System.out.println(s.length());//NullPointerException  

*3) Error
Error is irrecoverable. Some example of errors are OutOfMemoryError, VirtualMachineError, AssertionError etc.

int a[]=new int[5];  
a[10]=50; //ArrayIndexOutOfBoundsException  
----------------------------------------------------------------------------
Exception handling techniques=>

1>  try-catch block=>

*Java try block is used to enclose the code that might throw an exception. It must be used within the method.
If an exception occurs at the particular statement in the try block, the rest of the block code 
will not execute. So, it is recommended not to keep the code in try block that will not throw an exception.

Java try block must be followed by either catch or finally block.

*Java catch block is used to handle the Exception by declaring the type of exception within the parameter.
 The declared exception must be the parent class exception ( i.e., Exception) or the generated exception type.
 However, the good approach is to declare the generated type of exception.

The catch block must be used after the try block only. You can use multiple catch block with a single try block.

try catch internal working=>
*The JVM firstly checks whether the exception is handled or not. If exception is not handled,
 JVM provides a default exception handler that performs the following tasks:

Prints out exception description.
Prints the stack trace (Hierarchy of methods where the exception occurred).
Causes the program to terminate.

*But if the application programmer handles the exception, the normal 
flow of the application is maintained, i.e., rest of the code is executed.

problem without exception handling->

public class TryCatchExample1 {  
  
    public static void main(String[] args) {  
          
        int data=50/0; //may throw exception   
          
        System.out.println("rest of the code");  
          
    }  
      
}  

Output:

Exception in thread "main" java.lang.ArithmeticException: / by zero


solution->  

public class TryCatchExample2 {  
  
    public static void main(String[] args) {  
        try  
        {  
        int data=50/0; //may throw exception   
        }  
            //handling the exception  
        catch(ArithmeticException e)  
        {  
            System.out.println(e);  
        }  
        System.out.println("rest of the code");  
    }  
      
}  

Output:

java.lang.ArithmeticException: / by zero
rest of the code



public class TryCatchExample10 {  
  
    public static void main(String[] args) {  
          
          
        PrintWriter pw;  
        try {  
            pw = new PrintWriter("jtp.txt"); //may throw exception   
            pw.println("saved");  
        }  
// providing the checked exception handler  
 catch (FileNotFoundException e) {  
              
            System.out.println(e);  
        }         
    System.out.println("File saved successfully");  
    }  
}  


o/p file saved successfully

------------------------------------------------------------------------------------------
Multi-catch block
A try block can be followed by one or more catch blocks. Each catch block must contain a different exception handler. 
So, if you have to perform different tasks at the occurrence of different exceptions, use java multi-catch block.

Points to remember
At a time only one exception occurs and at a time only one catch block is executed.
All catch blocks must be ordered from most specific to most general, i.e. catch for ArithmeticException
 must come before catch for Exception.

ex  public class MultipleCatchBlock1 {  
  
    public static void main(String[] args) {  
          
           try{    
                int a[]=new int[5];    
                a[5]=30/0;    
               }    
               catch(ArithmeticException e)  
                  {  
                   System.out.println("Arithmetic Exception occurs");  
                  }    
               catch(ArrayIndexOutOfBoundsException e)  
                  {  
                   System.out.println("ArrayIndexOutOfBounds Exception occurs");  
                  }    
               catch(Exception e)  
                  {  
                   System.out.println("Parent Exception occurs");  
                  }             
               System.out.println("rest of the code");    
    }  
}  


------------------------------------------------------------------------------
nested try block->

*In Java, using a try block inside another try block is permitted. It is called 
as nested try block. Every statement that we enter a statement in try block.
For example, the inner try block can be used to handle ArrayIndexOutOfBoundsException
 while the outer try block can handle the ArithemeticException (division by zero).

*For example, the inner try block can be used to handle ArrayIndexOutOfBoundsException while 
the outer try block can handle the ArithemeticException (division by zero).

*For example, the inner try block can be used to handle ArrayIndexOutOfBoundsException 
while the outer try block can handle the ArithemeticException (division by zero).

*Why use nested try block
Sometimes a situation may arise where a part of a block may cause one error and the entire block 
itself may cause another error. In such cases, exception handlers have to be nested.

public class NestedTryBlock{    
 public static void main(String args[]){   
 //outer try block   
  try{    
  //inner try block 1  
    try{    
     System.out.println("going to divide by 0");    
     int b =39/0;    
   }  
    //catch block of inner try block 1  
    catch(ArithmeticException e)  
    {  
      System.out.println(e);  
    }    
       
    
    //inner try block 2  
    try{    
    int a[]=new int[5];    
  
    //assigning the value out of array bounds  
     a[5]=4;    
     }  
  
    //catch block of inner try block 2  
    catch(ArrayIndexOutOfBoundsException e)  
    {  
       System.out.println(e);  
    }    
  
      
    System.out.println("other statement");    
  }  
  //catch block of outer try block  
  catch(Exception e)  
  {  
    System.out.println("handled the exception (outer catch)");  
  }    
    
  System.out.println("normal flow..");    
 }    
}  


*When any try block does not have a catch block for a particular exception, then the catch block 
of the outer (parent) try block are checked for that exception, 
and if it matches, the catch block of outer try block is executed.

If none of the catch block specified in the code is unable to handle the exception,
 then the Java runtime system will handle the exception. Then it displays the system generated message for that exception.


-------------------------------------------------------------------------------------------------

Finally Block->  Java finally block is a block used to execute important code such as closing the connection, etc.
Java finally block is always executed whether an exception is handled or not. Therefore, it contains 
all the necessary statements that need to be printed regardless of the exception occurs or not.

The finally block follows the try-catch block.

Note: If you don't handle the exception, before terminating the program, JVM executes finally block (if any).

*Why use Java finally block?
finally block in Java can be used to put "cleanup" code such as closing a file, closing connection, etc.
The important statements to be printed can be placed in the finally block.

*ex.   

class TestFinallyBlock {    
  public static void main(String args[]){    
  try{    
//below code do not throw any exception  
   int data=25/5;    
   System.out.println(data);    
  }    
//catch won't be executed  
  catch(NullPointerException e){  
System.out.println(e);  
}    
//executed regardless of exception occurred or not  
 finally {  
System.out.println("finally block is always executed");  
}    
    
System.out.println("rest of phe code...");    
  }    
}    

o/p=>finally block is always executed  
       rest of phe code



when exception is occured=>

public class TestFinallyBlock1{    
      public static void main(String args[]){   
  
      try {    
  
        System.out.println("Inside the try block");  
          
        //below code throws divide by zero exception  
       int data=25/0;    
       System.out.println(data);    
      }    
      //cannot handle Arithmetic type exception  
      //can only accept Null Pointer type exception  
      catch(NullPointerException e){  
        System.out.println(e);  
      }   
  
      //executes regardless of exception occured or not   
      finally {  
        System.out.println("finally block is always executed");  
      }    
  
      System.out.println("rest of the code...");    
      }    
    }    

o/p=>inside the try block
       finally block is always
         exception

*Rule: For each try block there can be zero or more catch blocks, but only one finally block.
*Note: The finally block will not be executed if the program exits (either by calling System.exit()
 or by causing a fatal error that causes the process to abort).

--------------------------------------------------------------------
Throw keyword=>   

*In Java, exceptions allows us to write good quality codes where the errors are checked at the compile time
 instead of runtime and we can create custom exceptions making the code recovery and debugging easier

*he Java throw keyword is used to throw an exception explicitly.

We specify the exception object which is to be thrown. The Exception has some message with it that provides
 the error description. These exceptions may be related to user inputs, server, etc.

*We can throw either checked or unchecked exceptions in Java by throw keyword. 
It is mainly used to throw a custom exception.

*We can throw either checked or unchecked exceptions in Java by throw keyword. It is mainly used to throw a custom exception.
*We can also define our own set of conditions and throw an exception explicitly using throw keyword.


ex.  

public class TestThrow1 {   
    //function to check if person is eligible to vote or not   
    public static void validate(int age) {  
        if(age<18) {  
            //throw Arithmetic exception if not eligible to vote  
            throw new ArithmeticException("Person is not eligible to vote");    
        }  
        else {  
            System.out.println("Person is eligible to vote!!");  
        }  
    }  
    //main method  
    public static void main(String args[]){  
        //calling the function  
        validate(13);  
        System.out.println("rest of the code...");    
  }    
}    


*If we throw a checked exception using throw keyword, it is must to handle
 the exception using catch block or the method must declare it using throws declaration.

ex.

public class TestThrow2 {   
  
    //function to check if person is eligible to vote or not   
    public static void method() throws FileNotFoundException {  
  
        FileReader file = new FileReader("C:\\Users\\Anurati\\Desktop\\abc.txt");  
        BufferedReader fileInput = new BufferedReader(file);  
  
      
        throw new FileNotFoundException();  
      
    }  
    //main method  
    public static void main(String args[]){  
        try  
        {  
            method();  
        }   
        catch (FileNotFoundException e)   
        {  
            e.printStackTrace();  
        }  
        System.out.println("rest of the code...");    
  }    
}    
Output
fiilenotfound
rest of code


ex.   

class UserDefinedException extends Exception  
{  
    public UserDefinedException(String str)  
    {  
        // Calling constructor of parent Exception  
        super(str);  
    }  
}  
// Class that uses above MyException  
public class TestThrow3  
{  
    public static void main(String args[])  
    {  
        try  
        {  
            // throw an object of user defined exception  
            throw new UserDefinedException("This is user-defined exception");  
        }  
        catch (UserDefinedException ude)  
        {  
            System.out.println("Caught the exception");  
            // Print the message from MyException object  
            System.out.println(ude.getMessage());  
        }  
    }  
}   
Output:
------------------------------------------------------------------------------------------------------
exception prepogation->

*An exception is first thrown from the top of the stack and if it is not caught, it drops down the 
call stack to the previous method. If not caught there, the exception again drops down to the previous method,
 and so on until they are caught or until they reach the very bottom of the call stack. This is called exception propagation.

Note: By default Unchecked Exceptions are forwarded in calling chain (propagated).

class TestExceptionPropagation1{  
  void m(){  
    int data=50/0;  
  }  
  void n(){  
    m();  
  }  
  void p(){  
   try{  
    n();  
   }catch(Exception e){System.out.println("exception handled");}  
  }  
  public static void main(String args[]){  
   TestExceptionPropagation1 obj=new TestExceptionPropagation1();  
   obj.p();  
   System.out.println("normal flow...");  
  }  
}  

o/p->exception handled
       normal flow..

*Note: By default, Checked Exceptions are not forwarded in calling chain (propagated).

-------------------------------------------------------------------------------
throws keyword->
*The Java throws keyword is used to declare an exception. It gives an information to the programmer 
that there may occur an exception. So, it is better for the programmer to provide the exception handling code 
so that the normal flow of the program can be maintained.

Exception Handling is mainly used to handle the checked exceptions.

Which exception should be declared?
Ans: Checked exception only, because:
unchecked exception: under our control so we can correct our code.

*Advantage of Java throws keyword
Now Checked Exception can be propagated (forwarded in call stack).

It provides information to the caller of the method about the exception.

lass Testthrows1{  
  void m()throws IOException{  
    throw new IOException("device error");//checked exception  
  }  
  void n()throws IOException{  
    m();  
  }  
  void p(){  
   try{  
    n();  
   }catch(Exception e){System.out.println("exception handled");}  
  }  
  public static void main(String args[]){  
   Testthrows1 obj=new Testthrows1();  
   obj.p();  
   System.out.println("normal flow...");  
  }  
}  


*There are two cases:

Case 1: We have caught the exception i.e. we have handled the exception using try/catch block.
Case 2: We have declared the exception i.e. specified throws keyword with the method.

 If we are calling a method that declares an exception, we must either caught or declare the exception.


diff b/w throw and throws=>

*Using throw keyword, we can declare both checked and unchecked exceptions.
 However, the throws keyword can be used to propagate checked exceptions only.
*Syntax	The throw keyword is followed by an instance of Exception to be thrown.	
The throws keyword is followed by class names of Exceptions to be thrown.
4Declaration	throw is used within the method.	
throws is used with the method signature.
*Internal implementation We are allowed to throw only one exception at a time i.e. we cannot throw multiple exceptions.	
We can declare multiple exceptions using throws keyword that can be thrown by the method. For example, 
main() throws IOException, SQLException.

--------------------------------------------------
method overriding with exception=>

If the superclass method does not declare an exception, 
subclass overridden method cannot declare the checked exception but it can declare unchecked exception.
If the superclass method declares an exception
If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception.
_____________________________________________________________________________________________________

return type and logical interview questiions based on exception=>

Case 1: Return statement in try block but do not have return statement at the end of method

public class TryReturnTest1 
{
 int m1() // Compile time error.
 { 
   try {
      System.out.println("I am in try block");
      return 50;
   }
   catch(Exception e)
   {
     System.out.println("I am in catch block");
   }
 // Here, no return statement at the end of method.
 }
 public static void main(String[] args) 
 {
  TryReturnTest1 ft = new TryReturnTest1();
   System.out.println(ft.m1());
  }
}
In the preceding program, we did not return a value at the end of the method. Therefore, we will get compile-time error: “This method must return a result of type int”. So, this is an invalid case.

------------------------------
Case 2: Return statement in try block and end of method.

public class TryReturnTest2 
{
 int m1()
 {
   try {
      System.out.println("I am in try block");
      return 50;
   }
   catch(Exception e)
   {
      System.out.println("I am in catch block");
    }
  return 20; // return statement at the end of a method.
}
public static void main(String[] args) 
{
  TryReturnTest2 ft = new TryReturnTest2();
  System.out.println(ft.m1());
  }
}

o/p  -> I am in try block
         50       //catch not execute because exception is not occured
-----------------------------------

Case 3: Return statement in try block and at end of method but exception occurred in try block.

public class TryReturnTest4
{
 int m1()
 {
   try {
      System.out.println("I am in try block");
      int x = 10/0;
      return 50;
   }
   catch(ArithmeticException ae)
   {
      System.out.println("I am in catch block");
   }
  return 20;
}
public static void main(String[] args) 
 {
  TryReturnTest4 ft = new TryReturnTest4();
   System.out.println(ft.m1());
  }
}
Output:
          I am in try block
          I am in catch block
          20
--------------------------------------
case :    
public class TryCatchReturn1
{
 int m1()
 {
    try {
       System.out.println("I am in try block");
       return 50;
    }
    catch(Exception e)
    {
       System.out.println("I am in catch block");
       return 30;
    }
 }
 public static void main(String[] args) 
 {
  TryCatchReturn1 obj = new TryCatchReturn1();
   System.out.println(obj.m1());
  }
}
Output:
         I am in try block
         50
---------------------------------------

public class CatchReturn1
{
 int m1()
 {
   try {
      System.out.println("I am in try block");
   }
   catch(Exception e)
   {
      System.out.println("I am in catch block");
      return 30; // return statement inside the catch block.
   }
  return 100; // return statement at the end of method
}
public static void main(String[] args) 
{
 CatchReturn1 obj = new CatchReturn1();
   System.out.println(obj.m1());
  }
}
Output:
         I am in try block
         100
---------------------------------------
Case :

public class CatchReturn2 {
int m1()
{
  try {
     System.out.println("I am in try block");
     int x = 20/0;
     System.out.println("Result: " +x);
  }
  catch(ArithmeticException ae)
  {
     System.out.println("I am in catch block");
     return 30;
  }
 return 100;
}
public static void main(String[] args) 
{
  CatchReturn2 obj = new CatchReturn2();
  System.out.println(obj.m1());
 }
}
Output:
      I am in try block
      I am in catch block
      30

-----------------------------------
case: 

public class FinallyReturn1
{
 int m1()
 {
   try {
      System.out.println("I am in try block");
      return 30;
   }
  finally {
      System.out.println("I am in finally block");	
      return 50;
  }
}
public static void main(String[] args) 
{
 FinallyReturn1 obj = new FinallyReturn1();
   System.out.println(obj.m1());
  }
}
Output:
      I am in try block
      I am in finally block
      50
---------------------------------------

public class FinallyReturn2
{
@SuppressWarnings("finally")
int m1()
{
  try {
     System.out.println("I am in try block");
     int x = 10/0;
     System.out.println("Result: " +x);
  }
  catch(ArithmeticException ae)
  {
    System.out.println("I am in catch block");
    return 40;
  }
 finally {
     System.out.println("I am in finally block");	
     return 50;
  }
}
public static void main(String[] args)
{
   FinallyReturn2 obj = new FinallyReturn2();
   System.out.println(obj.m1());
 }
}
Output: 
       I am in try block
       I am in catch block
       I am in finally block
       50
--------------------------------------
public class FinallyReturn3
{
@SuppressWarnings("finally")
int m1()
{ 
  int a = 20, b = 0;	
  try {
     System.out.println("I am in try block");
     int c = a/b;
     System.out.println("Result: " +c);
  }
  catch(ArithmeticException ae)
  {
    System.out.println("I am in catch block");
    return 40;
  }
  finally {
     System.out.println("I am in finally block");	
     return 50;
  }
 System.out.println("Statement after finally block");
}
public static void main(String[] args) 
{
   FinallyReturn3 obj = new FinallyReturn3();
   System.out.println(obj.m1());
 }
}
Output:
      Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
      Unreachable code error


*if in method return type int and in try and catch block condition  if in catch have return or method not have return 
 then not show any exception but if catch not have return and also method not have return then show exception.  
---------------------------------------------------------------
__________________________________________________________________________________________________________
MULTITHREADING BASED INTERVIEW QUESTIONS=>

*1) What is multithreading?
Multithreading is a process of executing multiple threads simultaneously. Multithreading is used to obtain the
 multitasking. It consumes less memory and gives the fast and efficient performance. Its main advantages are:
Threads share the same address space.
The thread is lightweight.
The cost of communication between the processes is low.

-------------------------------------------------------------------
2) What is the thread?
A thread is a lightweight subprocess. It is a separate path of execution because each 
thread runs in a different stack frame. A process may contain multiple threads. 
Threads share the process resources, but still, they execute independently.
-----------------------------------------------------------------
3) Differentiate between process and thread?
There are the following differences between the process and thread.

A Program in the execution is called the process whereas; A thread is a subset of the process
Processes are independent whereas threads are the subset of process.
Process have different address space in memory, while threads contain a shared address space.
Context switching is faster between the threads as compared to processes.
-------------------------------------------------------------------
4) What do you understand by inter-thread communication?
The process of communication between synchronized threads is termed as inter-thread communication.
------------------------------------------------------------------
6) Why must wait() method be called from the synchronized block?
We must call the wait method otherwise it will throw java.lang.IllegalMonitorStateException exception.
--------------------------------------------------------------------
7) What are the advantages of multithreading?
Multithreading programming has the following advantages:

Multithreading allows an application/program to be always reactive for input, even already running with some background tasks
Multithreading allows the faster execution of tasks, as threads execute independently.
Multithreading provides better utilization of cache memory as threads share the common memory resources.
--------------------------------------------------------------------------
9) What is the difference between preemptive scheduling and time slicing?
Under preemptive scheduling, the highest priority task executes until it enters 
the waiting or dead states or a higher priority task comes into existence. Under time slicing, 
a task executes for a predefined slice of time and then reenters the pool of ready tasks. 
The scheduler then determines which task should execute next, based on priority and other factors.
---------------------------------------------------------------------------
10) What is context switching?
In Context switching the state of the process (or thread) is stored so that it 
can be restored and execution can be resumed from the same point later. Context switching
 enables the multiple processes to share the same CPU.
----------------------------------------------------------------------------
15) Is it possible to start a thread twice?
No, we cannot restart the thread, as once a thread started and executed, it goes to
 the Dead state. Therefore, if we try to start a thread twice, it will give a runtimeException 
"java.lang.IllegalThreadStateException".
-------------------------------------------------------------------------------
17) What about the daemon threads?
The daemon threads are the low priority threads that provide the background support and services to the user
 threads. Daemon thread gets automatically terminated by the JVM if the program remains with 
the daemon thread only, and all other user threads are ended/died. There are two methods for daemon thread available in the Thread class:

public void setDaemon(boolean status): It used to mark the thread daemon thread or a user thread.
public boolean isDaemon(): It checks the thread is daemon or not.
More details.
------------------------------------------------------------------------------------------
18)Can we make the user thread as daemon thread if the thread is started?
No, if you do so, it will throw IllegalThreadStateException. Therefore, 
we can only create a daemon thread before starting the thread.
----------------------------------------------------------------------------------
Interrupting a Thread:
If any thread is in sleeping or waiting state (i.e. sleep() or wait() is invoked),
 calling the interrupt() method on the thread, breaks out the sleeping or waiting state throwing 
InterruptedException. If the thread is not in the sleeping or waiting state, calling the interrupt() method performs normal behaviour and doesn't interrupt the thread but sets the interrupt flag to true. Let's first see the methods provided by the Thread class for thread interruption.

The 3 methods provided by the Thread class for interrupting a thread

public void interrupt()
public static boolean interrupted()
public boolean isInterrupted()

Example of interrupting a thread that stops working
Play

Next
Unmute
Current TimeÂ 
0:00
/
DurationÂ 
18:10
Â 
Fullscreen

Backward Skip 10s

Play Video

Forward Skip 10s
In this example, after interrupting the thread, we are propagating it, so it will stop working. If we don't want to stop the thread, we can handle it where sleep() or wait() method is invoked. Let's first see the example where we are propagating the exception.

TestInterruptingThread1.java

class TestInterruptingThread1 extends Thread{  
public void run(){  
try{  
Thread.sleep(1000);  
System.out.println("task");  
}catch(InterruptedException e){  
throw new RuntimeException("Thread interrupted..."+e);  
}  
  
}  
  
public static void main(String args[]){  
TestInterruptingThread1 t1=new TestInterruptingThread1();  
t1.start();  
try{  
t1.interrupt();  
}catch(Exception e){System.out.println("Exception handled "+e);}  
  
}  
}  
Test it Now
download this example
Output:

Exception in thread-0  
       java.lang.RuntimeException: Thread interrupted...
       java.lang.InterruptedException: sleep interrupted
       at A.run(A.java:7)
Example of interrupting a thread that doesn't stop working
In this example, after interrupting the thread, we handle the exception, so it will break out the sleeping but will not stop working.

TestInterruptingThread2.java

class TestInterruptingThread2 extends Thread{  
public void run(){  
try{  
Thread.sleep(1000);  
System.out.println("task");  
}catch(InterruptedException e){  
System.out.println("Exception handled "+e);  
}  
System.out.println("thread is running...");  
}  
  
public static void main(String args[]){  
TestInterruptingThread2 t1=new TestInterruptingThread2();  
t1.start();  
  
t1.interrupt();  
  
}  
}  
Test it Now
download this example
Output:

Exception handled  
       java.lang.InterruptedException: sleep interrupted
       thread is running...
------------------------------------------------------------
25)What is the difference between notify() and notifyAll()?
The notify() is used to unblock one waiting thread whereas notifyAll() method is used to unblock all the 
threads in waiting state.
------------------------------------------------------------
27) How to detect a deadlock condition? How can it be avoided?
We can detect the deadlock condition by running the code on cmd and collecting the Thread Dump, and if any deadlock is present in 
the code, then a message will appear on cmd.

Ways to avoid the deadlock condition in Java:

Avoid Nested lock: Nested lock is the common reason for deadlock as deadlock occurs when we 
provide locks to various threads so we should give one lock to only one thread at some particular time.
Avoid unnecessary locks: we must avoid the locks which are not required.
Using thread join: Thread join helps to wait for a thread until another thread doesn't finish its execution 
so we can avoid deadlock by maximum use of join method.
----------------------------------------------------------------
30) How is the safety of a thread achieved?

Synchronization
Using Volatile keyword
Using a lock based mechanism
Use of atomic wrapper classes
---------------------------------------------------------------------
31) What is race-condition?
A Race condition is a problem which occurs in the multithreaded programming when various
 threads execute simultaneously accessing a shared resource at the same time. The proper use of 
synchronization can avoid the Race condition.

-----------------------------------------------------------------------------------
33) What do you understand by thread pool?
Java Thread pool represents a group of worker threads, which are waiting for the task to be allocated.
Threads in the thread pool are supervised by the service provider which pulls one thread from the pool and assign a job to it.
After completion of the given task, thread again came to the thread pool.
The size of the thread pool depends on the total number of threads kept at reserve for execution.
The advantages of the thread pool are :

Using a thread pool, performance can be enhanced.
Using a thread pool, better system stability can occur.
-------------------------------------------------------------------------------------
34) What are the main components of concurrency API?
Concurrency API can be developed using the class and interfaces of java.util.Concurrent package.
 There are the following classes and interfaces in java.util.Concurrent package.

Executor
FarkJoinPool
ExecutorService
ScheduledExecutorService
Future
TimeUnit(Enum)
CountDownLatch
CyclicBarrier
Semaphore
ThreadFactory
BlockingQueue
DelayQueue
Locks
Phaser


executer=>The Executor Interface provided by the package java.util.concurrent is the simple interface
 used to execute the new task. The execute() method of Executor interface is used to execute some given command.

public class TestThread {  
   public static void main(final String[] arguments) throws InterruptedException {  
      Executor e = Executors.newCachedThreadPool();  
      e.execute(new Thread());  
      ThreadPoolExecutor pool = (ThreadPoolExecutor)e;  
      pool.shutdown();  
   }    
  
   static class Thread implements Runnable {  
      public void run() {  
         try {  
            Long duration = (long) (Math.random() * 5);  
            System.out.println("Running Thread!");  
            TimeUnit.SECONDS.sleep(duration);  
            System.out.println("Thread Completed");  
         } catch (InterruptedException ex) {  
            ex.printStackTrace();  
         }  
      }  
   }  
} 

1) SingleThreadExecutor
The SingleThreadExecutor is a special type of executor that has only a single thread. 
It is used when we need to execute tasks in sequential order.
ExecutorService executor = Executors.newSingleThreadExecutor()  

2) FixedThreadPool(n)
FixedThreadPool is another special type of executor that is a thread pool having a fixed number of threads. 
By this executor, the submitted task is executed by the n thread.
xecutorService executor = Executors.newFixedThreadPool(4);  

3) CachedThreadPool
The CachedThreadPool is a special type of thread pool that is used to execute short-lived parallel tasks. 

4) ScheduledExecutor
The ScheduledExecutor is another special type of executor which we use to run a certain task at regular intervals. 




----------------------------------------------------------------------
__ExecuterService=>
Java ExecutorService
The Java ExecutorService is the interface which allows us to execute tasks on threads asynchronously. 
The Java ExecutorService interface is present in the java.util.concurrent package. 
The ExecutorService helps in maintaining a pool of threads and assigns them tasks. 


boolean isShutdown()	This method returns whether the given executor is shut down or not.
boolean isTerminated()	This method returns true if all tasks have executed after shutdown.
void shutdown()	This method allows completion of previously submitted tasks to
 the ExecutorService and doesn?t allow any other tasks to be accepted.

public class ExecutorServiceExample {  
  
    public static void main(String[] args) {  
        ExecutorService executorService = Executors.newFixedThreadPool(10);  
        executorService.execute(new Runnable() {  
              
            @Override  
            public void run() {  
                System.out.println("ExecutorService");  
                  
            }  
        });  
        executorService.shutdown();  
    }  
  
}  



public class ExecutorServiceExample {  
  
    public static void main(String[] args) {  
        ExecutorService executorService = Executors.newSingleThreadExecutor();  
        executorService.submit(new Runnable() {  
              
            @Override  
            public void run() {  
                System.out.println("ExecutorService");  
                  
            }  
        });  
    }  
}  

__________________________________________________________________________________________________________

ARRAY=>
*Normally, an array is a collection of similar type of elements which has contiguous memory location.
*Java array is an object which contains elements of a similar data type. Additionally, The elements 
of an array are stored in a contiguous memory location. It is a data structure where we store similar elements. 
We can store only a fixed set of elements in a Java array.

Array in Java is index-based, the first element of the array is stored at the 0th index,
 2nd element is stored on 1st index and so on.

*In Java, array is an object of a dynamically generated class. Java array inherits the Object class, 
and implements the Serializable as well as Cloneable interfaces. 

*Advantages
Code Optimization: It makes the code optimized, we can retrieve or sort the data efficiently.
Random access: We can get any data located at an index position.

Disadvantages
Size Limit: We can store only the fixed size of elements in the array. 
It doesn't grow its size at runtime. To solve this problem, collection framework is used in Java which grows automatically.

There are two types of array.

Single Dimensional Array
Multidimensional Array

----------------------------------------------------
class Testarray{  
public static void main(String args[]){  
int a[]=new int[5];//declaration and instantiation  
a[0]=10;//initialization  
a[1]=20;  
a[2]=70;  
a[3]=40;  
a[4]=50;  
//traversing array  
for(int i=0;i<a.length;i++)//length is the property of array  
System.out.println(a[i]);  
}}  
-----------------------------------------------------
dynamic array=>

Here a question arises that what if we want to insert an element and there is no more
 space is left for the new element? Here, the concept of dynamic array comes into existence. 
It expends the size of the array dynamically.

*The dynamic array is a variable size list data structure.
 It grows automatically when we try to insert an element if there is no more 
space left for the new element. It allows us to add and remove elements. It allocates memory at run time using the heap.
 It can change its size during run time.

*Size vs. Capacity
The initialization of a dynamic array creates a fixed-size array. In the following figure,
 the array implementation has 10 indices. We have added five elements to the array. Now, 
the underlying array has a length of five. Therefore, the length of the dynamic array size is 5 and its capacity is 10. 

*Resizing a Dynamic Array in Java
We need to resize an array in two scenarios if:

The array uses extra memory than required.
The array occupies all the memory and we need to add elements.

-------------------------------------------------------
get input from user in array=>

public class A  {
	public static void main(String[] args) {
		System.out.println("enter arr length");
		Scanner sc=new Scanner(System.in);
		int len = sc.nextInt();
		int a[]=new int[len];
		for(int i=0;i<a.length;i++) {
			System.out.println("enter "+ i+"  "+"element");
			a[i]=sc.nextInt();
		}
		System.out.println("new array");
		for(int a1:a) {
			System.out.println(a1);
		}
	}
	}



----------------------------------------------------
class Testarray1{  
public static void main(String args[]){  
int a[]={33,3,4,5};//declaration, instantiation and initialization  
//printing array  
for(int i=0;i<a.length;i++)//length is the property of array  
System.out.println(a[i]);  
}}  
------------------------------------------------------------
anonyms array=>
public class TestAnonymousArray{  
//creating a method which receives an array as a parameter  
static void printArray(int arr[]){  
for(int i=0;i<arr.length;i++)  
System.out.println(arr[i]);  
}  
  
public static void main(String args[]){  
printArray(new int[]{10,22,44,66});//passing anonymous array to method  
}}  
------------------------------------------------------------------
multidimentional array=>
class Testarray3{  
public static void main(String args[]){  
//declaring and initializing 2D array  
int arr[][]={{1,2,3},{2,4,5},{4,4,5}};  
//printing 2D array  
for(int i=0;i<3;i++){  
 for(int j=0;j<3;j++){  
   System.out.print(arr[i][j]+" ");  
 }  
 System.out.println();  
}  
}} 



public class A  {
	public static void main(String args[]){  
		//declaring and initializing 2D array  
		int arr[][]={{1,2,3,8},{2,4,5,9},{4,4,5,23},{2,4,5,9},{4,4,5,23}};  
		System.out.println(arr.length);
		//printing 2D array  
		for(int i=0;i<3;i++){  
		 for(int j=0;j<4;j++){ 
			
		   System.out.print(arr[i][j]+" "); 
		//   System.out.println(arr[0][2]);
		  
		 }  
		 System.out.println("");  
		}  
		}
}
 
o/p=>5
1 2 3 8 
2 4 5 9 
4 4 5 23 


* row length is consider as a length of array.
----------------------------------------------------------------------------------
public class A  {
	public static void main(String args[]){  
		//declaring and initializing 2D array  
		int arr[][]=new int[2][4];
		arr[0][0]=34;
arr[0][1]=12;
arr[0][2]=54;
arr[0][3]=12;
arr[1][0]=11;
arr[1][1]=22;
arr[1][2]=33;
arr[1][3]=44;

		System.out.println(arr.length);
		//printing 2D array  
		for(int i=0;i<2;i++){  
		 for(int j=0;j<4;j++){ 
			
		   System.out.print(arr[i][j]+" "); 
		//   System.out.println(arr[0][2]);
		  
		 }  
		 System.out.println("");  
		}  
		}
}
-----------------------------------------------------------

Jagged arrays are multidimensional arrays in which the member arrays are of different sizes. As an example, we can make a 2D array where the
 first array contains three elements, and the second array consists of four elements.
class TestJaggedArray{  
    public static void main(String[] args){  
        //declaring a 2D array with odd columns  
        int arr[][] = new int[3][];  
        arr[0] = new int[3];  
        arr[1] = new int[4];  
        arr[2] = new int[2];  
        //initializing a jagged array  
        int count = 0;  
        for (int i=0; i<arr.length; i++)  
            for(int j=0; j<arr[i].length; j++)  
                arr[i][j] = count++;  
   
        //printing the data of a jagged array   
        for (int i=0; i<arr.length; i++){  
            for (int j=0; j<arr[i].length; j++){  
                System.out.print(arr[i][j]+" ");  
            }  
            System.out.println();//new line  
        }  
    }  
}  


Output:

0 1 2 
3 4 5 6 
7 8 
-----------------------------------------------
get class name of java array=>

Class c=arr.getClass();  
String name=c.getName();  
------------------------------------------------------
//Java Program to copy a source array into a destination array in Java  
class TestArrayCopyDemo {  
    public static void main(String[] args) {  
        //declaring a source array  
        char[] copyFrom = { 'd', 'e', 'c', 'a', 'f', 'f', 'e',  
                'i', 'n', 'a', 't', 'e', 'd' };  
        //declaring a destination array  
        char[] copyTo = new char[7];  
        //copying array using System.arraycopy() method  
        System.arraycopy(copyFrom, 2, copyTo, 0, 7);  
        //printing the destination array  
        System.out.println(String.valueOf(copyTo));  
    }  
}  
------------------------------------------------------
//Java Program to demonstrate the addition of two matrices in Java  
class Testarray5{  
public static void main(String args[]){  
//creating two matrices  
int a[][]={{1,3,4},{3,4,5}};  
int b[][]={{1,3,4},{3,4,5}};  
  
//creating another matrix to store the sum of two matrices  
int c[][]=new int[2][3];  
  
//adding and printing addition of 2 matrices  
for(int i=0;i<2;i++){  
for(int j=0;j<3;j++){  
c[i][j]=a[i][j]+b[i][j];  
System.out.print(c[i][j]+" ");  
}  
System.out.println();//new line  
}  
  
}}
----------------------------------------------------------
multiplication of two array=>
public class MatrixMultiplicationExample{  
public static void main(String args[]){  
//creating two matrices    
int a[][]={{1,1,1},{2,2,2},{3,3,3}};    
int b[][]={{1,1,1},{2,2,2},{3,3,3}};    
    
//creating another matrix to store the multiplication of two matrices    
int c[][]=new int[3][3];  //3 rows and 3 columns  
    
//multiplying and printing multiplication of 2 matrices    
for(int i=0;i<3;i++){    
for(int j=0;j<3;j++){    
c[i][j]=0;      
for(int k=0;k<3;k++)      
{      
c[i][j]+=a[i][k]*b[k][j];      
}//end of k loop  
System.out.print(c[i][j]+" ");  //printing matrix element  
}//end of j loop  
System.out.println();//new line    
}    
}}  

o/p=>

6 6 6 
12 12 12 
18 18 18 
---------------------------------------------------------
user defned obj type array=>
public class A  {
	public static void main(String args[]){  
		Product[] obj = new Product[5] ;  
		//create & initialize actual product objects using constructor  
		obj[0] = new Product(23907,"Dell Laptop");  
		obj[1] = new Product(91240,"HP 630");  
		obj[2] = new Product(29823,"LG OLED TV");  
		obj[3] = new Product(11908,"MI Note Pro Max 9");  
		obj[4] = new Product(43590,"Kingston USB");  
		
		for(Product p:obj) {
			System.out.println(p.getPro_Id()+","+p.getPro_name());
		}
		}
}
-------------------------------------------------------
interview questions =>

Q. sort array with min complexity
-------------------------------------------------------------------------
Q what is time complexity and how to calculate time complexity 
*Time Complexity considers how many times each statement executes. 
*Time Complexity: In the above code “Hello World” is printed only once on the screen. 
So, the time complexity is constant: O(1)
O ->big O notation 
nested for loop=>
for(){
for(){
for(){}
statement 1
}
}

n*n*n*o(1)=on3
two loops complexity=>m+n*O(1)=O(m+n)
3 for loops O(n)+O(n)+O(n)=3O(n)
--------------------------------------------------------------------------------------------------
Q remove duplicates from array
first sort and the

public class RemoveDuplicateInArrayExample{  
public static int removeDuplicateElements(int arr[], int n){  
        if (n==0 || n==1){  
            return n;  
        }  
        int[] temp = new int[n];  
        int j = 0;  
        for (int i=0; i<n-1; i++){  
            if (arr[i] != arr[i+1]){  
                temp[j++] = arr[i];  
            }  
         }  
        temp[j++] = arr[n-1];     
        // Changing original array  
        for (int i=0; i<j; i++){  
            arr[i] = temp[i];  
        }  
        return j;  
    }  
       
    public static void main (String[] args) {  
        int arr[] = {10,20,20,30,30,40,50,50};  
        int length = arr.length;  
        length = removeDuplicateElements(arr, length);  
        //printing array elements  
        for (int i=0; i<length; i++)  
           System.out.print(arr[i]+" ");  
    }  
}  
--------------------------------------------------------------

Q. Mention some advantages and disadvantages of Arrays.
Advantages:

Multiple elements of Array can be sorted at the same time.
Using the index, we can access any element in O(1) time.
Disadvantages:

You need to specify how many elements you're going to store in your array ahead of time and We can not increase or decrease the size of the Array after creation.
You have to shift the other elements to fill in or close gaps, which takes worst-case O(n) time.
---------------------------------------------------

3. What will happen if you do not initialize an Array?
The array will take default values depending upon the data type.
----------------------------------------------------------------
6. Can you declare an array without assigning the size of an array?
No, we cannot declare an array without assigning size. If we declare an array without size, it will throw compile time error.
----------------------------------------------------------
Q 7. Where is an Array stored in JVM memory?
An Array is an object in java. So, Array is stored in heap memory in Java Virtual Machine.
---------------------------------------------------------------------------
11. When will we get ArrayStoreException?
ArrayStoreException is a runtime exception. 
For example, you will get this exception at run time if you declare a String
 Array and then try to insert integer elements in the array. 
----------------------------------------------------------
13. We know that Arrays are objects so why cannot we write strArray.length()?
We cannot write strArray.length() because length is not a method, it's a data item of an array. We can use the 
methods of Object like toString() and hashCode() against Array
-------------------------------------------------------------
Q  How do you find the missing integer in an array of range 1 to 100?
--------------------------------------------------------------
Q How do you remove a particular element from an array?
----------------------------------------------------------------
Q How to check the equality of two arrays?
Arrays.equals(a,b)


---------------------------------------------------------
Q find out smallest and largest number in a given Array?
sort array and find
--------------------------------------------------------------
Q. print duplicatw elements of array


--------------------------------------------------------------
Q.   Program to find the frequency of each element in the array

class GFG
{
 
    static void countFreq(int arr[], int n)
    {
        Map<Integer, Integer> mp = new HashMap<>();
 
        // Traverse through array elements and
        // count frequencies
        for (int i = 0; i < n; i++)
        {
            if (mp.containsKey(arr[i]))
            {
                mp.put(arr[i], mp.get(arr[i]) + 1);
            }
            else
            {
                mp.put(arr[i], 1);
            }
        }
        // Traverse through map and print frequencies
        for (Map.Entry<Integer, Integer> entry : mp.entrySet())
        {
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }
 
    // Driver code
    public static void main(String args[])
    {
        int arr[] = {10, 20, 20, 10, 10, 20, 5, 20};
        int n = arr.length;
        countFreq(arr, n);
    }
}

--------------------------------------------------------------
Q  find nth max or nth min element of array

sort array and then array[array.length-n]
-------------------------------------------------------------
Q  Java Program to print Odd and Even Numbers from an Array

  public class OddEvenInArrayExample{  
public static void main(String args[]){  
int a[]={1,2,5,6,3,2};  
System.out.println("Odd Numbers:");  
for(int i=0;i<a.length;i++){  
if(a[i]%2!=0){  
System.out.println(a[i]);  
}  
}  
System.out.println("Even Numbers:");  
for(int i=0;i<a.length;i++){  
if(a[i]%2==0){  
System.out.println(a[i]);  
}  
}  

________________________________________________________________________________________________________________________________________________________________________________________
****************************************************************************************************************************************************************************************

OTHER TOPICS RELATED INTERVIEW QUESTIONS=>
transient keyword=>Transient in Java is used to mark the member variable not to be serialized when 
it is persisted to streams of bytes. This keyword plays an important role to meet security constraints in Java.
 It ignores the original value of a variable and saves the default value of that variable data type.
*in other words at a time of serialization if you don't want the load value of variable 
* For example, if a program accepts a user's login details and password. But we don't want to store the original password in the file.
 Here, we can use transient keyword 
*Let's take an example, we have declared a class as Student, it has three data members id, name and age. If you serialize the object, all the values will be serialized but we don't want to serialize one value, 
e.g. age then we can declare the age data member as transient.
==========================================================***********=============================================================
volatile keyword=>*Volatile keyword is used to modify the value of a variable by different threads. 
*It is also used to make classes thread safe.
*It means that multiple threads can use a method and instance of the classes at the same time without any problem.

------------------------------------------------
When to use it?
You can use a volatile variable if you want to read and write long and double variable automatically.
It can be used as an alternative way of achieving synchronization in Java.
-----------------------------------------------------
rules=>

You can use the volatile keyword with variables. Using volatile keyword with classes and methods is illegal.
It guarantees that value of the volatile variable will always be read from the main memory, not from the local thread cache.
If you declared variable as volatile, Read and Writes are atomic
===========================================================************==========================================================
method hiding=>

Method hiding can be defined as, "if a subclass defines a static method with the same signature as a static 
method in the super class, in such a case, the method in the subclass hides the one in the superclass.
" The mechanism is known as method hiding. It happens because static methods are resolved at compile time.

-----------------------------------------------------------
*Method Hiding Factors (MHF)->
The method hiding factors measure the invisibilities of methods in classes.
Ideally, the method hiding factor must have a large value.

formula=>total invisible methods/total no. of methods in app

class Demo  
{  
public static void method1()  
{  
System.out.println("Method-1 of the Demo class is executed.");  
}  
public void method2()  
{  
System.out.println("Method-2 of the Demo class is executed.");  
}  
}  
//child class  
public class Sample extends Demo  
{  
public static void method1()  
{  
System.out.println("Method-1 of the Sample class is executed.");  
}  
public void method2()  
{  
System.out.println("Method-2 of the Sample class is executed.");  
}  
public static void main(String args[])  
{  
Demo d1 = new Demo();  
//d2 is reference variable of class Demo that points to object of class Sample  
Demo d2 = new Sample();  
//method calling with reference (method hiding)  
d1.method1();  
d2.method1();  
//method calling with object (method overriding)  
d1.method2();  
d2.method2();  
}  
}  
Output:

Method-1 of the Demo class is executed.
Method-1 of the Demo class is executed.
Method-2 of the Demo class is executed.
Method-2 of the Sample class is executed.
-------------------------------------------------------------------------
Finalize method=>
*finalize is the method in Java which 
is used to perform clean up processing just before object is garbage collected.

*finalize() method is used with the objects.
*finalize method performs the cleaning activities with respect to the object before its destruction.
*finalize method is executed just before the object is destroyed.

public class FinalizeExample {    
     public static void main(String[] args)     
    {     
        FinalizeExample obj = new FinalizeExample();        
        // printing the hashcode   
        System.out.println("Hashcode is: " + obj.hashCode());           
        obj = null;    
        // calling the garbage collector using gc()   
        System.gc();     
        System.out.println("End of the garbage collection");     
    }     
   // defining the finalize method   
    protected void finalize()     
    {     
        System.out.println("Called the finalize() method");     
    }     
}    
----------------------------------------------------********-------------------------------------------------------
memory areas in java=>
1. Class (Method) Area
The class method area is the memory block that stores the class code, variable 
code(static variable, runtime constant), method code, and the constructor of a Java program


2. Program Counter Register: 
Each JVM thread that carries out the task of a specific method has a program counter register 
associated with it. The non-native method has a PC that stores the address of the available JVM 
instruction whereas, in a native method, the value of the program counter is undefined

35. Native method Stacks: 
Also called C stacks, native method stacks are not written in Java language. 

4*In Java, memory management is a vital process. It is managed by Java automatically.
 The JVM divides the memory into two parts: stack memory and heap memory. From the perspective of Java,
 both are important memory areas but both are used for different purposes. The major difference between
 Stack memory and heap memory is that the stack is used to store the order of method execution and local
 variables while the heap memory stores the objects and it uses dynamic memory allocation and deallocation.

diff b/w heap and stack mem area=>

Stack Memory                                                    	Heap Space
It stores items that have a very short life such
 as methods,variables, and reference variables of the objects. 	  It stores objects and Java Runtime Environment (JRE) classes.

It follows the LIFO order.	                                   It does not follow any order because it is a dynamic
                                                            memory allocation and does not have any fixed pattern for allocation 
                                                            and deallocation of memory blocks.

It is not flexible because we cannot alter the allocated memory.	It is flexible because we can alter the allocated memory.
It has faster access, allocation, and deallocation.	           It has slower access, allocation, and deallocation.
	It is smaller in size.                                   	It is larger in size.

The variables are visible only to the owner thread.	            It is visible to all threads.
JVM throws the java.lang.StackOverFlowError if the 
stack size is greater than the limit.
   To avoid this error, increase the stack size.	      JVM throws the java.lang.OutOfMemoryError if the JVM is unable to create a new native method.
it is done automatically by the compiler.	                  It is done manually by the programmer.

Order of allocation	Memory allocation is continuous.	 Memory allocated in random order.
Thread-Safety	It is thread-safe because each thread has its own stack.	It is not thread-safe, so properly synchronization of code is required.
-----------------------------------------------------------------------
Perm gen=>*PermGen (Permanent Generation) is a special heap space separated from the main memory heap.
           All the static content is stored by the JVM to this memory section. Static content can be a 
           static method, references to the static object and primitive variables. PermGen also contains
              information about bytecode, names, and JIT. 

*The JVM memory is divided into two parts, which are as follows:

1>PermGen Space (Permanent Generation)
2>Heap Space
Eden Space(Young Generation)
Survivor Space(Young Generation)
Old Generation


*The PermGen space contains the internal representation of the Java classes that JVM holds. 
The Permanent Generation is the garbage data that is collected in the same way as heap's other 
parts collected. It is a special area of memory that contains meta-data of the program's classes
 and the program's objects. It also contains the class-loaders that are manually destroyed at the 
end of the use. Here, the Garbage Collector is not that efficient and due to which it causes 
the Out of Memory: PermGen space error quite a few times.

*The main disadvantage of the PermGen space is that it's maximum size is fixed. 
The 64 MB and the 82 MB are the maximum memory size for 32-bit and 64-bit version of JVM, 
respectively. We can modify its default size with the help of the following options:

meta space=>
Simply put, Metaspace is a new memory space – starting from the Java 8 version; it has replaced the older
 PermGen memory space. The most significant difference is how it handles memory allocation.
Specifically, this native memory region grows automatically by default.

-----------------------------------------------------------------------------
diff b/w  preemgen and metaspace=>

PermGen	MetaSpace
It is removed from java 8.	It is introduced in Java 8.
PermGen always has a fixed maximum size.	Metaspace by default auto increases its size depending on the underlying OS.
Contiguous Java Heap Memory.	Native Memory(provided by underlying OS).
Inefficient garbage collection.	Efficient garbage collection.
-----------------------------------------------------------------------------
Causes of java.lang.OutOfMemoryError
The error triggers when the application attempts to add more data into the heap space area,
 but there is not enough space for it. 
JVM throws Java heap space error whenever it reaches the heap size limit.
__________________________________________________________________________________________________________
SOLID pricipals=>
*in Java, SOLID principles are an object-oriented approach that are applied to software structure design. 
*also changed the way of writing software. It also ensures that the software is modular,
 easy to understand, debug, and refactor.

*Single Responsibility Principle->
The single responsibility principle states that every Java class must perform a single functionality. 
Implementation of multiple functionalities in a single class mashup the code and if any modification is 
required may affect the whole class. It precise the code and the code can be easily maintained.

public class Student  
{  
public void printDetails();  
{  
//functionality of the method  
}  
pubic void calculatePercentage();  
{  
//functionality of the method  
}  
public void addStudent();  
{  
//functionality of the method  
}  
}  

public class Student  
{  
public void addStudent();  
{  
//functionality of the method  
}  
}  
PrintStudentDetails.java

public class PrintStudentDetails  
{  
public void printDetails();  
{  
//functionality of the method  
}  
}  


*Open-Closed Principle=>

The open-closed principle states that according to new requirements the module should be open for
 extension but closed for modification. The extension allows us to implement new functionality to the module. 

Suppose, VehicleInfo is a class and it has the method vehicleNumber() that returns the vehicle number.

VehicleInfo.java

public class VehicleInfo  
{  
public double vehicleNumber(Vehicle vcl)   
{  
if (vcl instanceof Car)   
{  
return vcl.getNumber();  
if (vcl instanceof Bike)   
{  
return vcl.getNumber();  
}  
}  
If we want to add another subclass named Truck, simply, we add one more if statement that violates the open-closed principle. The only way to add the subclass and achieve the goal of principle by overriding the vehicleNumber() method, as we have shown below.

VehicleInfo.java

public class VehicleInfo   
{  
public double vehicleNumber()   
{  
//functionality   
}  
}  
public class Car extends VehicleInfo   
{  
public double vehicleNumber()   
{  
return this.getValue();  
}  
public class Car extends Truck   
{  
public double vehicleNumber()   
{  
return this.getValue();  
}  
Similarly, we can add more vehicles by making another subclass extending from the vehicle class. the approach would not affect the existing application.



*Liskov Substitution Principle=>

*It applies to inheritance in such a way that the derived classes must be completely substitutable 
for their base classes. In other words, if class A is a subtype of class B, then we should be able to
 replace B with A without interrupting the behavior of the program.

public class Student   
{  
private double height;  
private double weight;  
public void setHeight(double h)   
{   
height = h;   
}  
public void setWeight(double w)   
{   
weight= w;   
}  
...  
}  
public class StudentBMI extends Student  
{  
public void setHeight(double h)   
{  
super.setHeight(h);  
super.setWeight(w);  
}  
public void setWeight(double h)   
{  
super.setHeight(h);  
super.setWeight(w);  
}  
}  
The above classes violated the Liskov substitution principle because the StudentBMI class has extra constraints i.e.
 height and weight that must be the same. Therefore, the Student class (base class) cannot be replaced by StudentBMI class (derived class).

Hence, substituting the class Student with StudentBMI class may result in unexpected behavior.

Interface Segregation Principle=>
The principle states that the larger interfaces split into smaller ones. Because the implementation classes use only the methods that are required. We should not force the client to use the methods that they do not want to use.

The goal of the interface segregation principle is similar to the single responsibility principle. 
public interface Conversion  
{  
public void intToDouble();  
public void intToChar();  
public void charToString();  
}  
The above interface has three methods. If we want to use only a method intToChar(), we have no choice to implement the 
single method. To overcome the problem, the principle allows us to split the interface into three separate ones.

public interface ConvertIntToDouble  
{  
public void intToDouble();  
}   
public interface ConvertIntToChar  
{  
public void intToChar();  
}  
public interface ConvertCharToString   
{  
public void charToString();  
}  
Now we can use only the method that is required. Suppose, we want to convert the integer to 
double and character to string then, we will use only the methods intToDouble() and charToString().

Dependency Inversion Principle
The principle states that we must use abstraction (abstract classes and interfaces) instead of concrete
 implementations. High-level modules should not depend on the low-level module but both should depend on 
the abstraction. Because the abstraction does not depend on detail but the detail depends on abstraction. 


-----------------------------------------------
Q >unit test case if method not have any return type
 Assert.assertEquals(expectedArea, actualArea); 


============================================================************=========================================================

spring boot 2.7.11 version does not support @Entity
--------------------------

_
Microservices=>

Microservices communication->

1> feign client->


*It is provide synchronous communication
Netflix provides Feign as an abstraction over REST-based calls, by which microservices can communicate with each other, but developers don't have to bother about REST internal details.

why use feign client rather then resttemplate->

* One of the advantages of using Feign over RestTemplate is that, we do not need to write any implementation
 to call the other services.

*One of the advantages of using Feign over RestTemplate is that, we do not need to write any implementation to call the other services. So there is no need to write any unit test as there is no code to test in the first place.

*code eimplementation=>  

two microservices ItemMicroservice,UserMicroservice

step1->
add in UserMicroservice

 <dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

step2->

@EnableFeignClients
@SpringBootApplication
@EnableEurekaClient
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UsersApplication.class, args);
    }
}


step3->  spring.application.name=item-service,add in ItemMicroservice app.properties

step4->

 @FeignClient(name = "item-service")
public interface ItemsServiceClient {

    @GetMapping(value = "/item/user-items")
    public List<Item> getItems(@RequestParam Long userId);
}

step5->  public class ItemController {
    @Autowired
    ItemService itemService;
   
    @GetMapping(value = "/user-items")
    public ResponseEntity<List<Item>> getItemByUserId(@RequestParam(value = "userId") Long userId){
        return new ResponseEntity<List<Item>>(itemService.findAllItemsByUserId(userId), HttpStatus.OK);
    }
}

-------------------------------------------------------------------------------------------
web client=>  
step1 ->

 <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>


step 2->@Bean
@LoadBalanced
public WebClient.Builder loadBalancedWebClientBuilder() {
 return WebClient.builder();
}

Step3 ->@Autowired
private WebClient.Builder webClientBuilder;

@GetMapping("/{id}/with-accounts")
public Mono findByIdWithAccounts(@PathVariable("id") String id) {
 LOGGER.info("findByIdWithAccounts: id={}", id);
 Flux accounts = webClientBuilder.build().get().uri("http://account-service/customer/{customer}", id).retrieve().bodyToFlux(Account.class);
 return accounts
  .collectList()
  .map(a -> new Customer(a))
  .mergeWith(repository.findById(id))
  .collectList()
  .map(CustomerMapper::map);
}

why use webclient->

While the Feign client creates a thread for each request and blocks it until it receives a response, the WebClient executes the HTTP request and adds a “waiting for response” task into a queue.

*Webclient support asynchrounous communication.

-------------------------------------------**********-------------------------------------------

loadbalancing-> Load balancing is the process of distributing traffic among different instances of the same application. To create a fault-tolerant system, it's common to run multiple instances of each application. Thus, whenever one service needs to communicate with another, it needs to pick a particular instance to send its request.



----------------------------------------
Synchronous communication is the exchange of information between 2 or more people in real-time. It may be in person but it certainly doesn't have to be. In addition to in-person conversations or meetings, phone calls and video meetings are also examples of synchronous communication.

*Asynchronous communication refers to any kind of communication where there is a delay between when a message is sent and when the person on the other end receives and interprets it. It is usually not an in-person type of communication and is rarely scheduled.
ex . email ,chating
_______________________________________________________________________________________________________
string  x;
int y

public boolean equals(Product p) {
	if(p.getX().equals(this.getX())&&(p.getY()==this.getY())) {
		return true;
	}
		
		return false;
	}
-----------------------------------------------------------------------


 


 
         
